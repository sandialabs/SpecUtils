/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.2.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif

#if __cplusplus >=201103L
# define SWIG_NULLPTR nullptr
#else
# define SWIG_NULLPTR NULL
#endif 


/* C99 and C++11 should provide snprintf, but define SWIG_NO_SNPRINTF
 * if you're missing it.
 */
#if ((defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L) || \
     (defined __cplusplus && __cplusplus >= 201103L) || \
     defined SWIG_HAVE_SNPRINTF) && \
    !defined SWIG_NO_SNPRINTF
# define SWIG_snprintf(O,S,F,A) snprintf(O,S,F,A)
# define SWIG_snprintf2(O,S,F,A,B) snprintf(O,S,F,A,B)
#else
/* Fallback versions ignore the buffer size, but most of our uses either have a
 * fixed maximum possible size or dynamically allocate a buffer that's large
 * enough.
 */
# define SWIG_snprintf(O,S,F,A) sprintf(O,F,A)
# define SWIG_snprintf2(O,S,F,A,B) sprintf(O,F,A,B)
#endif



#ifndef SWIGEXTERN
# ifdef __cplusplus
#   define SWIGEXTERN extern
# else
#   define SWIGEXTERN
# endif
#endif


#define SWIG_exception_impl(DECL, CODE, MSG, RETURNNULL) \
 { throw std::logic_error("In " DECL ": " MSG); }


enum SwigMemFlags {
    SWIG_MEM_OWN = 0x01,
    SWIG_MEM_RVALUE = 0x02,
};


#define SWIG_check_nonnull(PTR, TYPENAME, FNAME, FUNCNAME, RETURNNULL) \
  if (!(PTR)) { \
    SWIG_exception_impl(FUNCNAME, SWIG_NullReferenceError, \
                        "Cannot pass null " TYPENAME " (class " FNAME ") " \
                        "as a reference", RETURNNULL); \
  }


#define SWIG_check_range(INDEX, SIZE, FUNCNAME, RETURNNULL) \
  if (!(INDEX < SIZE)) { \
    SWIG_exception_impl(FUNCNAME, SWIG_IndexError, \
                        "index out of range", RETURNNULL); \
  }


namespace swig {
enum AssignmentType {
  ASSIGNMENT_DEFAULT,
  ASSIGNMENT_NODESTRUCT,
  ASSIGNMENT_SMARTPTR
};
}


#define SWIG_check_sp_nonnull(PTR, TYPENAME, FNAME, FUNCNAME, RETURNNULL) \
  if (!(PTR)) { \
    SWIG_exception_impl(FUNCNAME, SWIG_NullReferenceError, \
                        "Cannot pass null " TYPENAME " (class " FNAME ") " \
                        "as a reference", RETURNNULL); \
  }

#define SWIG_sp_mem_flags 0



#define SWIG_VERSION 0x040200
#define SWIGFORTRAN
#define SWIGPOLICY_std_vector_Sl__Sp_int_SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_vector_Sl__Sp_double_SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_vector_Sl__Sp_float_SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_vector_Sl__Sp_SpecUtils_Measurement_SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_shared_ptr_Sl__Sp_vector_Sl__Sp_SpecUtils_Measurement_SP__Sg__SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_shared_ptr_Sl__Sp_q_Sp_const_SP__Sf_vector_Sl__Sp_SpecUtils_Measurement_SP__Sg__SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_shared_ptr_Sl__Sp_SpecUtils_Measurement_SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_shared_ptr_Sl__Sp_q_Sp_const_SP__Sf_SpecUtils_Measurement_SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_shared_ptr_Sl__Sp_std_vector_Sl__Sp_float_SP__Sg__SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_std_shared_ptr_Sl__Sp_q_Sp_const_SP__Sf_std_vector_Sl__Sp_float_SP__Sg__SP__Sg_ swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_SpecUtils_Measurement swig::ASSIGNMENT_SMARTPTR
#define SWIGPOLICY_SpecUtils_SpecFile swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_SpecUtils_DetectorAnalysisResult swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_SpecUtils_DetectorAnalysis swig::ASSIGNMENT_DEFAULT
#define SWIGPOLICY_SpecUtils_MultimediaData swig::ASSIGNMENT_DEFAULT

#ifdef __cplusplus
#include <utility>
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigSmartPointer {
    T *ptr;
    SwigSmartPointer(T *p) : ptr(p) { }
    ~SwigSmartPointer() { delete ptr; }
    SwigSmartPointer& operator=(SwigSmartPointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
    void reset(T *p) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = p; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigSmartPointer tmp(new T(t)); pointer = tmp; return *this; }
#if __cplusplus >=201103L
  SwigValueWrapper& operator=(T&& t) { SwigSmartPointer tmp(new T(std::move(t))); pointer = tmp; return *this; }
  operator T&&() const { return std::move(*pointer.ptr); }
#else
  operator T&() const { return *pointer.ptr; }
#endif
  T *operator&() const { return pointer.ptr; }
  static void reset(SwigValueWrapper& t, T *p) { t.pointer.reset(p); }
};

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
template <typename T> T SwigValueInit() {
  return T();
}

#if __cplusplus >=201103L
# define SWIG_STD_MOVE(OBJ) std::move(OBJ)
#else
# define SWIG_STD_MOVE(OBJ) OBJ
#endif

#endif


#include <stdexcept>


/* Support for the `contract` feature.
 *
 * Note that RETURNNULL is first because it's inserted via a 'Replaceall' in
 * the fortran.cxx file.
 */
#define SWIG_contract_assert(RETURNNULL, EXPR, MSG) \
 if (!(EXPR)) { SWIG_exception_impl("$decl", SWIG_ValueError, MSG, RETURNNULL); } 


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <SpecUtils/SpecFile.h>



#include <utility>


#include <set>


#include <string>


#include <vector>


struct SwigClassWrapper {
    void* cptr;
    int cmemflags;
};


SWIGINTERN SwigClassWrapper SwigClassWrapper_uninitialized() {
    SwigClassWrapper result;
    result.cptr = NULL;
    result.cmemflags = 0;
    return result;
}

SWIGINTERN void std_vector_Sl_int_Sg__set(std::vector< int > *self,std::vector< int >::size_type index,int const &v){
        SWIG_check_range(index, self->size(),
                         "std::vector<""int" ">::set",
                         return);
        (*self)[index] = v;
      }
SWIGINTERN int const &std_vector_Sl_int_Sg__get(std::vector< int > *self,std::vector< int >::size_type index){
        SWIG_check_range(index, self->size(),
                         "std::vector<""int" ">::get",
                         return self->front());
        return (*self)[index];
      }
SWIGINTERN void std_vector_Sl_int_Sg__insert(std::vector< int > *self,std::vector< int >::size_type index,int const &v){
        SWIG_check_range(index, self->size() + 1,
                         "std::vector<""int" ">::insert",
                         return);
        self->insert(self->begin() + index, v);
      }
SWIGINTERN void std_vector_Sl_int_Sg__erase__SWIG_0(std::vector< int > *self,std::vector< int >::size_type index){
        SWIG_check_range(index, self->size(),
                         "std::vector<""int" ">::remove",
                         return);
        self->erase(self->begin() + index);
      }
SWIGINTERN void std_vector_Sl_int_Sg__erase__SWIG_1(std::vector< int > *self,std::vector< int >::size_type start_index,std::vector< int >::size_type stop_index){
        SWIG_check_range(start_index, stop_index + 1,
                         "std::vector<""int" ">::remove_range",
                         return);
        SWIG_check_range(stop_index, self->size() + 1,
                         "std::vector<""int" ">::remove_range",
                         return);
        self->erase(self->begin() + start_index, self->begin() + stop_index);
      }
SWIGINTERN int &std_vector_Sl_int_Sg__front_ref(std::vector< int > *self){
      return (*self).front();
    }
SWIGINTERN int &std_vector_Sl_int_Sg__back_ref(std::vector< int > *self){
      return (*self).back();
    }
SWIGINTERN int &std_vector_Sl_int_Sg__get_ref(std::vector< int > *self,std::vector< int >::size_type index){
      SWIG_check_range(index, self->size(),
                       "std::vector<""int" ">::get_ref",
                       return self->front());
      return (*self)[index];
    }

namespace swig {

template<class T, AssignmentType A>
struct DestructorPolicy {
  static SwigClassWrapper destroy(SwigClassWrapper self) {
    delete static_cast<T*>(self.cptr);
    return SwigClassWrapper_uninitialized();
  }
};
template<class T>
struct DestructorPolicy<T, ASSIGNMENT_NODESTRUCT> {
  static SwigClassWrapper destroy(SwigClassWrapper) {
    SWIG_exception_impl("assignment", SWIG_TypeError, "Invalid assignment: class type has private destructor", return SwigClassWrapper_uninitialized());
  }
};
}


namespace swig {

SWIGINTERN SwigClassWrapper capture(SwigClassWrapper other) {
  other.cmemflags &= ~SWIG_MEM_RVALUE;
  return other;
}

template<class T, AssignmentType A>
struct AssignmentPolicy {
  static SwigClassWrapper destroy(SwigClassWrapper self) {
    return DestructorPolicy<T, A>::destroy(self);
  }
  static SwigClassWrapper alias(SwigClassWrapper other) {
    SwigClassWrapper self = other;
    self.cmemflags &= ~SWIG_MEM_OWN;
    return self;
  }
  static SwigClassWrapper move_alias(SwigClassWrapper self, SwigClassWrapper other) {
    if (self.cmemflags & SWIG_MEM_OWN) {
      destroy(self);
    }
    return capture(other);
  }
  static SwigClassWrapper copy_alias(SwigClassWrapper self, SwigClassWrapper other) {
    if (self.cmemflags & SWIG_MEM_OWN) {
      destroy(self);
    }
    return capture(other);
  }
};

template<class T>
struct AssignmentPolicy<T, ASSIGNMENT_SMARTPTR> {
  static SwigClassWrapper destroy(SwigClassWrapper self) {
    return DestructorPolicy<T, ASSIGNMENT_SMARTPTR>::destroy(self);
  }
  static SwigClassWrapper alias(SwigClassWrapper other) {
    SwigClassWrapper self;
    self.cptr = new T(*static_cast<T*>(other.cptr));
    self.cmemflags = other.cmemflags | SWIG_MEM_OWN;
    return self;
  }
  static SwigClassWrapper move_alias(SwigClassWrapper self, SwigClassWrapper other) {
    self = copy_alias(self, other);
    self.cmemflags = other.cmemflags & ~SWIG_MEM_RVALUE;
    destroy(other);
    return self;
  }
  static SwigClassWrapper copy_alias(SwigClassWrapper self, SwigClassWrapper other) {
    // LHS and RHS should both 'own' their shared pointers
    T *pself = static_cast<T*>(self.cptr);
    T *pother = static_cast<T*>(other.cptr);
    *pself = *pother;
    return self;
  }
};

} // end namespace swig

template<class T, swig::AssignmentType A>
SWIGINTERN void SWIG_assign(SwigClassWrapper* self, SwigClassWrapper other) {
  typedef swig::AssignmentPolicy<T, A> Policy_t;

  if (self->cptr == NULL) {
    /* LHS is unassigned */
    if (other.cmemflags & SWIG_MEM_RVALUE) {
      /* Capture pointer from RHS, clear 'moving' flag */
      *self = swig::capture(other);
    } else {
      /* Aliasing another class; clear ownership or copy smart pointer */
      *self = Policy_t::alias(other);
    }
  } else if (other.cptr == NULL) {
    /* Replace LHS with a null pointer */
    *self = Policy_t::destroy(*self);
  } else if (self->cptr == other.cptr) {
    /* Self-assignment: ignore */
  } else if (other.cmemflags & SWIG_MEM_RVALUE) {
    /* Transferred ownership from a variable that's about to be lost.
     * Move-assign and delete the transient data */
    *self = Policy_t::move_alias(*self, other);
  } else {
    /* RHS shouldn't be deleted, alias to LHS */
    *self = Policy_t::copy_alias(*self, other);
  }
}

template<class T, swig::AssignmentType A>
SWIGINTERN void SWIG_free_rvalue(SwigClassWrapper other) {
  typedef swig::AssignmentPolicy<T, A> Policy_t;
  if (other.cmemflags & SWIG_MEM_RVALUE 
      && other.cmemflags & SWIG_MEM_OWN) {
    /* We own *and* are being passed an expiring value */
    Policy_t::destroy(other);
  }
}


SWIGINTERN void std_vector_Sl_double_Sg__set(std::vector< double > *self,std::vector< double >::size_type index,double const &v){
        SWIG_check_range(index, self->size(),
                         "std::vector<""double" ">::set",
                         return);
        (*self)[index] = v;
      }
SWIGINTERN double const &std_vector_Sl_double_Sg__get(std::vector< double > *self,std::vector< double >::size_type index){
        SWIG_check_range(index, self->size(),
                         "std::vector<""double" ">::get",
                         return self->front());
        return (*self)[index];
      }
SWIGINTERN void std_vector_Sl_double_Sg__insert(std::vector< double > *self,std::vector< double >::size_type index,double const &v){
        SWIG_check_range(index, self->size() + 1,
                         "std::vector<""double" ">::insert",
                         return);
        self->insert(self->begin() + index, v);
      }
SWIGINTERN void std_vector_Sl_double_Sg__erase__SWIG_0(std::vector< double > *self,std::vector< double >::size_type index){
        SWIG_check_range(index, self->size(),
                         "std::vector<""double" ">::remove",
                         return);
        self->erase(self->begin() + index);
      }
SWIGINTERN void std_vector_Sl_double_Sg__erase__SWIG_1(std::vector< double > *self,std::vector< double >::size_type start_index,std::vector< double >::size_type stop_index){
        SWIG_check_range(start_index, stop_index + 1,
                         "std::vector<""double" ">::remove_range",
                         return);
        SWIG_check_range(stop_index, self->size() + 1,
                         "std::vector<""double" ">::remove_range",
                         return);
        self->erase(self->begin() + start_index, self->begin() + stop_index);
      }
SWIGINTERN double &std_vector_Sl_double_Sg__front_ref(std::vector< double > *self){
      return (*self).front();
    }
SWIGINTERN double &std_vector_Sl_double_Sg__back_ref(std::vector< double > *self){
      return (*self).back();
    }
SWIGINTERN double &std_vector_Sl_double_Sg__get_ref(std::vector< double > *self,std::vector< double >::size_type index){
      SWIG_check_range(index, self->size(),
                       "std::vector<""double" ">::get_ref",
                       return self->front());
      return (*self)[index];
    }
SWIGINTERN void std_vector_Sl_float_Sg__set(std::vector< float > *self,std::vector< float >::size_type index,float const &v){
        SWIG_check_range(index, self->size(),
                         "std::vector<""float" ">::set",
                         return);
        (*self)[index] = v;
      }
SWIGINTERN float const &std_vector_Sl_float_Sg__get(std::vector< float > *self,std::vector< float >::size_type index){
        SWIG_check_range(index, self->size(),
                         "std::vector<""float" ">::get",
                         return self->front());
        return (*self)[index];
      }
SWIGINTERN void std_vector_Sl_float_Sg__insert(std::vector< float > *self,std::vector< float >::size_type index,float const &v){
        SWIG_check_range(index, self->size() + 1,
                         "std::vector<""float" ">::insert",
                         return);
        self->insert(self->begin() + index, v);
      }
SWIGINTERN void std_vector_Sl_float_Sg__erase__SWIG_0(std::vector< float > *self,std::vector< float >::size_type index){
        SWIG_check_range(index, self->size(),
                         "std::vector<""float" ">::remove",
                         return);
        self->erase(self->begin() + index);
      }
SWIGINTERN void std_vector_Sl_float_Sg__erase__SWIG_1(std::vector< float > *self,std::vector< float >::size_type start_index,std::vector< float >::size_type stop_index){
        SWIG_check_range(start_index, stop_index + 1,
                         "std::vector<""float" ">::remove_range",
                         return);
        SWIG_check_range(stop_index, self->size() + 1,
                         "std::vector<""float" ">::remove_range",
                         return);
        self->erase(self->begin() + start_index, self->begin() + stop_index);
      }
SWIGINTERN float &std_vector_Sl_float_Sg__front_ref(std::vector< float > *self){
      return (*self).front();
    }
SWIGINTERN float &std_vector_Sl_float_Sg__back_ref(std::vector< float > *self){
      return (*self).back();
    }
SWIGINTERN float &std_vector_Sl_float_Sg__get_ref(std::vector< float > *self,std::vector< float >::size_type index){
      SWIG_check_range(index, self->size(),
                       "std::vector<""float" ">::get_ref",
                       return self->front());
      return (*self)[index];
    }
SWIGINTERN void std_vector_Sl_SpecUtils_Measurement_Sg__set(std::vector< SpecUtils::Measurement > *self,std::vector< SpecUtils::Measurement >::size_type index,SpecUtils::Measurement const &v){
        SWIG_check_range(index, self->size(),
                         "std::vector<""SpecUtils::Measurement" ">::set",
                         return);
        (*self)[index] = v;
      }
SWIGINTERN SpecUtils::Measurement const &std_vector_Sl_SpecUtils_Measurement_Sg__get(std::vector< SpecUtils::Measurement > *self,std::vector< SpecUtils::Measurement >::size_type index){
        SWIG_check_range(index, self->size(),
                         "std::vector<""SpecUtils::Measurement" ">::get",
                         return self->front());
        return (*self)[index];
      }
SWIGINTERN void std_vector_Sl_SpecUtils_Measurement_Sg__insert(std::vector< SpecUtils::Measurement > *self,std::vector< SpecUtils::Measurement >::size_type index,SpecUtils::Measurement const &v){
        SWIG_check_range(index, self->size() + 1,
                         "std::vector<""SpecUtils::Measurement" ">::insert",
                         return);
        self->insert(self->begin() + index, v);
      }
SWIGINTERN void std_vector_Sl_SpecUtils_Measurement_Sg__erase__SWIG_0(std::vector< SpecUtils::Measurement > *self,std::vector< SpecUtils::Measurement >::size_type index){
        SWIG_check_range(index, self->size(),
                         "std::vector<""SpecUtils::Measurement" ">::remove",
                         return);
        self->erase(self->begin() + index);
      }
SWIGINTERN void std_vector_Sl_SpecUtils_Measurement_Sg__erase__SWIG_1(std::vector< SpecUtils::Measurement > *self,std::vector< SpecUtils::Measurement >::size_type start_index,std::vector< SpecUtils::Measurement >::size_type stop_index){
        SWIG_check_range(start_index, stop_index + 1,
                         "std::vector<""SpecUtils::Measurement" ">::remove_range",
                         return);
        SWIG_check_range(stop_index, self->size() + 1,
                         "std::vector<""SpecUtils::Measurement" ">::remove_range",
                         return);
        self->erase(self->begin() + start_index, self->begin() + stop_index);
      }
SWIGINTERN SpecUtils::Measurement &std_vector_Sl_SpecUtils_Measurement_Sg__front_ref(std::vector< SpecUtils::Measurement > *self){
      return (*self).front();
    }
SWIGINTERN SpecUtils::Measurement &std_vector_Sl_SpecUtils_Measurement_Sg__back_ref(std::vector< SpecUtils::Measurement > *self){
      return (*self).back();
    }
SWIGINTERN SpecUtils::Measurement &std_vector_Sl_SpecUtils_Measurement_Sg__get_ref(std::vector< SpecUtils::Measurement > *self,std::vector< SpecUtils::Measurement >::size_type index){
      SWIG_check_range(index, self->size(),
                       "std::vector<""SpecUtils::Measurement" ">::get_ref",
                       return self->front());
      return (*self)[index];
    }

#include <memory>


#include <stdlib.h>
#ifdef _MSC_VER
# ifndef strtoull
#  define strtoull _strtoui64
# endif
# ifndef strtoll
#  define strtoll _strtoi64
# endif
#endif


struct SwigArrayWrapper {
    void* data;
    size_t size;
};


SWIGINTERN SwigArrayWrapper SwigArrayWrapper_uninitialized() {
  SwigArrayWrapper result;
  result.data = NULL;
  result.size = 0;
  return result;
}


#include <string.h>


struct SWIG_null_deleter {
  void operator() (void const *) const {
  }
};
#define SWIG_NO_NULL_DELETER_0 , SWIG_null_deleter()
#define SWIG_NO_NULL_DELETER_1
#define SWIG_NO_NULL_DELETER_SWIG_POINTER_NEW
#define SWIG_NO_NULL_DELETER_SWIG_POINTER_OWN

SWIGINTERN float SpecUtils_Measurement_gamma_count_at(SpecUtils::Measurement *self,int index){
        return self->gamma_counts()->at(index-1);
    }
SWIGINTERN std::shared_ptr< SpecUtils::Measurement const > SpecUtils_SpecFile_measurement_at(SpecUtils::SpecFile *self,int index){
        return self->measurement(static_cast<size_t>(index-1));
    }
extern "C" {
SWIGEXPORT SwigClassWrapper _wrap_new_IntVector__SWIG_0() {
  SwigClassWrapper fresult ;
  std::vector< int > *result = 0 ;
  
  result = (std::vector< int > *)new std::vector< int >();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_IntVector__SWIG_1(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  std::vector< int > *arg1 = 0 ;
  std::vector< int > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > const &", "IntVector", "std::vector< int >::vector(std::vector< int > const &)", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< int > *)farg1->cptr;
  result = (std::vector< int > *)new std::vector< int >((std::vector< int > const &)*arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_IntVector__SWIG_2(size_t const *farg1) {
  SwigClassWrapper fresult ;
  std::vector< int >::size_type arg1 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int >::size_type)(*farg1);
  result = (std::vector< int > *)new std::vector< int >(arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_IntVector__SWIG_3(size_t const *farg1, int const *farg2) {
  SwigClassWrapper fresult ;
  std::vector< int >::size_type arg1 ;
  int *arg2 = 0 ;
  int temp2 ;
  std::vector< int > *result = 0 ;
  
  arg1 = (std::vector< int >::size_type)(*farg1);
  temp2 = (int)(*farg2);
  arg2 = &temp2;
  result = (std::vector< int > *)new std::vector< int >(arg1,(int const &)*arg2);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT size_t _wrap_IntVector_size(SwigClassWrapper *farg1) {
  size_t fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > const *", "IntVector", "std::vector< int >::size() const", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  result = ((std::vector< int > const *)arg1)->size();
  fresult = (std::vector< int >::size_type)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_IntVector_capacity(SwigClassWrapper *farg1) {
  size_t fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > const *", "IntVector", "std::vector< int >::capacity() const", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  result = ((std::vector< int > const *)arg1)->capacity();
  fresult = (std::vector< int >::size_type)(result);
  return fresult;
}


SWIGEXPORT int _wrap_IntVector_empty(SwigClassWrapper *farg1) {
  int fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > const *", "IntVector", "std::vector< int >::empty() const", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  result = (bool)((std::vector< int > const *)arg1)->empty();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_IntVector_front(SwigClassWrapper *farg1) {
  int fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > const *", "IntVector", "std::vector< int >::front() const", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  result = (int *) &((std::vector< int > const *)arg1)->front();
  fresult = *result;
  return fresult;
}


SWIGEXPORT int _wrap_IntVector_back(SwigClassWrapper *farg1) {
  int fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > const *", "IntVector", "std::vector< int >::back() const", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  result = (int *) &((std::vector< int > const *)arg1)->back();
  fresult = *result;
  return fresult;
}


SWIGEXPORT void _wrap_IntVector_reserve(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::reserve(std::vector< int >::size_type)", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = (std::vector< int >::size_type)(*farg2);
  (arg1)->reserve(arg2);
}


SWIGEXPORT void _wrap_IntVector_resize__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::resize(std::vector< int >::size_type)", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = (std::vector< int >::size_type)(*farg2);
  (arg1)->resize(arg2);
}


SWIGEXPORT void _wrap_IntVector_resize__SWIG_1(SwigClassWrapper *farg1, size_t const *farg2, int const *farg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::resize(std::vector< int >::size_type,int const &)", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = (std::vector< int >::size_type)(*farg2);
  temp3 = (int)(*farg3);
  arg3 = &temp3;
  (arg1)->resize(arg2,(int const &)*arg3);
}


SWIGEXPORT void _wrap_IntVector_push_back(SwigClassWrapper *farg1, int const *farg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *arg2 = 0 ;
  int temp2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::push_back(int const &)", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  temp2 = (int)(*farg2);
  arg2 = &temp2;
  (arg1)->push_back((int const &)*arg2);
}


SWIGEXPORT void _wrap_IntVector_pop_back(SwigClassWrapper *farg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::pop_back()", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  (arg1)->pop_back();
}


SWIGEXPORT void _wrap_IntVector_clear(SwigClassWrapper *farg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::clear()", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  (arg1)->clear();
}


SWIGEXPORT void _wrap_IntVector_set(SwigClassWrapper *farg1, size_t const *farg2, int const *farg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::set(std::vector< int >::size_type,int const &)", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = *farg2 - 1;
  temp3 = (int)(*farg3);
  arg3 = &temp3;
  std_vector_Sl_int_Sg__set(arg1,SWIG_STD_MOVE(arg2),(int const &)*arg3);
}


SWIGEXPORT int _wrap_IntVector_get(SwigClassWrapper *farg1, size_t const *farg2) {
  int fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  int *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::get(std::vector< int >::size_type)", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = *farg2 - 1;
  result = (int *) &std_vector_Sl_int_Sg__get(arg1,SWIG_STD_MOVE(arg2));
  fresult = *result;
  return fresult;
}


SWIGEXPORT void _wrap_IntVector_insert(SwigClassWrapper *farg1, size_t const *farg2, int const *farg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  int *arg3 = 0 ;
  int temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::insert(std::vector< int >::size_type,int const &)", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = *farg2 - 1;
  temp3 = (int)(*farg3);
  arg3 = &temp3;
  std_vector_Sl_int_Sg__insert(arg1,SWIG_STD_MOVE(arg2),(int const &)*arg3);
}


SWIGEXPORT void _wrap_IntVector_erase__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::erase(std::vector< int >::size_type)", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = *farg2 - 1;
  std_vector_Sl_int_Sg__erase__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
}


SWIGEXPORT void _wrap_IntVector_erase__SWIG_1(SwigClassWrapper *farg1, size_t const *farg2, size_t const *farg3) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  std::vector< int >::size_type arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::erase(std::vector< int >::size_type,std::vector< int >::size_type)", return );
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = *farg2 - 1;
  arg3 = *farg3 - 1;
  std_vector_Sl_int_Sg__erase__SWIG_1(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
}


SWIGEXPORT int * _wrap_IntVector_front_ref(SwigClassWrapper *farg1) {
  int * fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::front_ref()", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  result = (int *) &std_vector_Sl_int_Sg__front_ref(arg1);
  fresult = result;
  return fresult;
}


SWIGEXPORT int * _wrap_IntVector_back_ref(SwigClassWrapper *farg1) {
  int * fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  int *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::back_ref()", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  result = (int *) &std_vector_Sl_int_Sg__back_ref(arg1);
  fresult = result;
  return fresult;
}


SWIGEXPORT int * _wrap_IntVector_get_ref(SwigClassWrapper *farg1, size_t const *farg2) {
  int * fresult ;
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::size_type arg2 ;
  int *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< int > *", "IntVector", "std::vector< int >::get_ref(std::vector< int >::size_type)", return 0);
  arg1 = (std::vector< int > *)farg1->cptr;
  arg2 = *farg2 - 1;
  result = (int *) &std_vector_Sl_int_Sg__get_ref(arg1,SWIG_STD_MOVE(arg2));
  fresult = result;
  return fresult;
}


SWIGEXPORT void _wrap_delete_IntVector(SwigClassWrapper *farg1) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  
  arg1 = (std::vector< int > *)farg1->cptr;
  delete arg1;
}


SWIGEXPORT void _wrap_IntVector_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int > *arg2 = 0 ;
  
  (void)sizeof(arg1);
  (void)sizeof(arg2);
  SWIG_assign<std::vector< int >, SWIGPOLICY_std_vector_Sl__Sp_int_SP__Sg_>(farg1, *farg2);
  
}


SWIGEXPORT SwigClassWrapper _wrap_new_DoubleVector__SWIG_0() {
  SwigClassWrapper fresult ;
  std::vector< double > *result = 0 ;
  
  result = (std::vector< double > *)new std::vector< double >();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_DoubleVector__SWIG_1(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  std::vector< double > *arg1 = 0 ;
  std::vector< double > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > const &", "DoubleVector", "std::vector< double >::vector(std::vector< double > const &)", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< double > *)farg1->cptr;
  result = (std::vector< double > *)new std::vector< double >((std::vector< double > const &)*arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_DoubleVector__SWIG_2(size_t const *farg1) {
  SwigClassWrapper fresult ;
  std::vector< double >::size_type arg1 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< double >::size_type)(*farg1);
  result = (std::vector< double > *)new std::vector< double >(arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_DoubleVector__SWIG_3(size_t const *farg1, double const *farg2) {
  SwigClassWrapper fresult ;
  std::vector< double >::size_type arg1 ;
  double *arg2 = 0 ;
  double temp2 ;
  std::vector< double > *result = 0 ;
  
  arg1 = (std::vector< double >::size_type)(*farg1);
  temp2 = (double)(*farg2);
  arg2 = &temp2;
  result = (std::vector< double > *)new std::vector< double >(arg1,(double const &)*arg2);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT size_t _wrap_DoubleVector_size(SwigClassWrapper *farg1) {
  size_t fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > const *", "DoubleVector", "std::vector< double >::size() const", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  result = ((std::vector< double > const *)arg1)->size();
  fresult = (std::vector< double >::size_type)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_DoubleVector_capacity(SwigClassWrapper *farg1) {
  size_t fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > const *", "DoubleVector", "std::vector< double >::capacity() const", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  result = ((std::vector< double > const *)arg1)->capacity();
  fresult = (std::vector< double >::size_type)(result);
  return fresult;
}


SWIGEXPORT int _wrap_DoubleVector_empty(SwigClassWrapper *farg1) {
  int fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > const *", "DoubleVector", "std::vector< double >::empty() const", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  result = (bool)((std::vector< double > const *)arg1)->empty();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT double _wrap_DoubleVector_front(SwigClassWrapper *farg1) {
  double fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > const *", "DoubleVector", "std::vector< double >::front() const", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  result = (double *) &((std::vector< double > const *)arg1)->front();
  fresult = *result;
  return fresult;
}


SWIGEXPORT double _wrap_DoubleVector_back(SwigClassWrapper *farg1) {
  double fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > const *", "DoubleVector", "std::vector< double >::back() const", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  result = (double *) &((std::vector< double > const *)arg1)->back();
  fresult = *result;
  return fresult;
}


SWIGEXPORT void _wrap_DoubleVector_reserve(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::reserve(std::vector< double >::size_type)", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = (std::vector< double >::size_type)(*farg2);
  (arg1)->reserve(arg2);
}


SWIGEXPORT void _wrap_DoubleVector_resize__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::resize(std::vector< double >::size_type)", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = (std::vector< double >::size_type)(*farg2);
  (arg1)->resize(arg2);
}


SWIGEXPORT void _wrap_DoubleVector_resize__SWIG_1(SwigClassWrapper *farg1, size_t const *farg2, double const *farg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::resize(std::vector< double >::size_type,double const &)", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = (std::vector< double >::size_type)(*farg2);
  temp3 = (double)(*farg3);
  arg3 = &temp3;
  (arg1)->resize(arg2,(double const &)*arg3);
}


SWIGEXPORT void _wrap_DoubleVector_push_back(SwigClassWrapper *farg1, double const *farg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *arg2 = 0 ;
  double temp2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::push_back(double const &)", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  temp2 = (double)(*farg2);
  arg2 = &temp2;
  (arg1)->push_back((double const &)*arg2);
}


SWIGEXPORT void _wrap_DoubleVector_pop_back(SwigClassWrapper *farg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::pop_back()", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  (arg1)->pop_back();
}


SWIGEXPORT void _wrap_DoubleVector_clear(SwigClassWrapper *farg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::clear()", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  (arg1)->clear();
}


SWIGEXPORT void _wrap_DoubleVector_set(SwigClassWrapper *farg1, size_t const *farg2, double const *farg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::set(std::vector< double >::size_type,double const &)", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = *farg2 - 1;
  temp3 = (double)(*farg3);
  arg3 = &temp3;
  std_vector_Sl_double_Sg__set(arg1,SWIG_STD_MOVE(arg2),(double const &)*arg3);
}


SWIGEXPORT double _wrap_DoubleVector_get(SwigClassWrapper *farg1, size_t const *farg2) {
  double fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  double *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::get(std::vector< double >::size_type)", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = *farg2 - 1;
  result = (double *) &std_vector_Sl_double_Sg__get(arg1,SWIG_STD_MOVE(arg2));
  fresult = *result;
  return fresult;
}


SWIGEXPORT void _wrap_DoubleVector_insert(SwigClassWrapper *farg1, size_t const *farg2, double const *farg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  double *arg3 = 0 ;
  double temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::insert(std::vector< double >::size_type,double const &)", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = *farg2 - 1;
  temp3 = (double)(*farg3);
  arg3 = &temp3;
  std_vector_Sl_double_Sg__insert(arg1,SWIG_STD_MOVE(arg2),(double const &)*arg3);
}


SWIGEXPORT void _wrap_DoubleVector_erase__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::erase(std::vector< double >::size_type)", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = *farg2 - 1;
  std_vector_Sl_double_Sg__erase__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
}


SWIGEXPORT void _wrap_DoubleVector_erase__SWIG_1(SwigClassWrapper *farg1, size_t const *farg2, size_t const *farg3) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  std::vector< double >::size_type arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::erase(std::vector< double >::size_type,std::vector< double >::size_type)", return );
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = *farg2 - 1;
  arg3 = *farg3 - 1;
  std_vector_Sl_double_Sg__erase__SWIG_1(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
}


SWIGEXPORT double * _wrap_DoubleVector_front_ref(SwigClassWrapper *farg1) {
  double * fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::front_ref()", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  result = (double *) &std_vector_Sl_double_Sg__front_ref(arg1);
  fresult = result;
  return fresult;
}


SWIGEXPORT double * _wrap_DoubleVector_back_ref(SwigClassWrapper *farg1) {
  double * fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  double *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::back_ref()", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  result = (double *) &std_vector_Sl_double_Sg__back_ref(arg1);
  fresult = result;
  return fresult;
}


SWIGEXPORT double * _wrap_DoubleVector_get_ref(SwigClassWrapper *farg1, size_t const *farg2) {
  double * fresult ;
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double >::size_type arg2 ;
  double *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< double > *", "DoubleVector", "std::vector< double >::get_ref(std::vector< double >::size_type)", return 0);
  arg1 = (std::vector< double > *)farg1->cptr;
  arg2 = *farg2 - 1;
  result = (double *) &std_vector_Sl_double_Sg__get_ref(arg1,SWIG_STD_MOVE(arg2));
  fresult = result;
  return fresult;
}


SWIGEXPORT void _wrap_delete_DoubleVector(SwigClassWrapper *farg1) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  
  arg1 = (std::vector< double > *)farg1->cptr;
  delete arg1;
}


SWIGEXPORT void _wrap_DoubleVector_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ;
  std::vector< double > *arg2 = 0 ;
  
  (void)sizeof(arg1);
  (void)sizeof(arg2);
  SWIG_assign<std::vector< double >, SWIGPOLICY_std_vector_Sl__Sp_double_SP__Sg_>(farg1, *farg2);
  
}


SWIGEXPORT SwigClassWrapper _wrap_new_FloatVector__SWIG_0() {
  SwigClassWrapper fresult ;
  std::vector< float > *result = 0 ;
  
  result = (std::vector< float > *)new std::vector< float >();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_FloatVector__SWIG_1(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  std::vector< float > *arg1 = 0 ;
  std::vector< float > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > const &", "FloatVector", "std::vector< float >::vector(std::vector< float > const &)", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< float > *)farg1->cptr;
  result = (std::vector< float > *)new std::vector< float >((std::vector< float > const &)*arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_FloatVector__SWIG_2(size_t const *farg1) {
  SwigClassWrapper fresult ;
  std::vector< float >::size_type arg1 ;
  std::vector< float > *result = 0 ;
  
  arg1 = (std::vector< float >::size_type)(*farg1);
  result = (std::vector< float > *)new std::vector< float >(arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_FloatVector__SWIG_3(size_t const *farg1, float const *farg2) {
  SwigClassWrapper fresult ;
  std::vector< float >::size_type arg1 ;
  float *arg2 = 0 ;
  float temp2 ;
  std::vector< float > *result = 0 ;
  
  arg1 = (std::vector< float >::size_type)(*farg1);
  temp2 = (float)(*farg2);
  arg2 = &temp2;
  result = (std::vector< float > *)new std::vector< float >(arg1,(float const &)*arg2);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT size_t _wrap_FloatVector_size(SwigClassWrapper *farg1) {
  size_t fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > const *", "FloatVector", "std::vector< float >::size() const", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  result = ((std::vector< float > const *)arg1)->size();
  fresult = (std::vector< float >::size_type)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_FloatVector_capacity(SwigClassWrapper *farg1) {
  size_t fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > const *", "FloatVector", "std::vector< float >::capacity() const", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  result = ((std::vector< float > const *)arg1)->capacity();
  fresult = (std::vector< float >::size_type)(result);
  return fresult;
}


SWIGEXPORT int _wrap_FloatVector_empty(SwigClassWrapper *farg1) {
  int fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > const *", "FloatVector", "std::vector< float >::empty() const", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  result = (bool)((std::vector< float > const *)arg1)->empty();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT float _wrap_FloatVector_front(SwigClassWrapper *farg1) {
  float fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > const *", "FloatVector", "std::vector< float >::front() const", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  result = (float *) &((std::vector< float > const *)arg1)->front();
  fresult = *result;
  return fresult;
}


SWIGEXPORT float _wrap_FloatVector_back(SwigClassWrapper *farg1) {
  float fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > const *", "FloatVector", "std::vector< float >::back() const", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  result = (float *) &((std::vector< float > const *)arg1)->back();
  fresult = *result;
  return fresult;
}


SWIGEXPORT void _wrap_FloatVector_reserve(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::reserve(std::vector< float >::size_type)", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = (std::vector< float >::size_type)(*farg2);
  (arg1)->reserve(arg2);
}


SWIGEXPORT void _wrap_FloatVector_resize__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::resize(std::vector< float >::size_type)", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = (std::vector< float >::size_type)(*farg2);
  (arg1)->resize(arg2);
}


SWIGEXPORT void _wrap_FloatVector_resize__SWIG_1(SwigClassWrapper *farg1, size_t const *farg2, float const *farg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  float *arg3 = 0 ;
  float temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::resize(std::vector< float >::size_type,float const &)", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = (std::vector< float >::size_type)(*farg2);
  temp3 = (float)(*farg3);
  arg3 = &temp3;
  (arg1)->resize(arg2,(float const &)*arg3);
}


SWIGEXPORT void _wrap_FloatVector_push_back(SwigClassWrapper *farg1, float const *farg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *arg2 = 0 ;
  float temp2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::push_back(float const &)", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  temp2 = (float)(*farg2);
  arg2 = &temp2;
  (arg1)->push_back((float const &)*arg2);
}


SWIGEXPORT void _wrap_FloatVector_pop_back(SwigClassWrapper *farg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::pop_back()", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  (arg1)->pop_back();
}


SWIGEXPORT void _wrap_FloatVector_clear(SwigClassWrapper *farg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::clear()", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  (arg1)->clear();
}


SWIGEXPORT void _wrap_FloatVector_set(SwigClassWrapper *farg1, size_t const *farg2, float const *farg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  float *arg3 = 0 ;
  float temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::set(std::vector< float >::size_type,float const &)", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = *farg2 - 1;
  temp3 = (float)(*farg3);
  arg3 = &temp3;
  std_vector_Sl_float_Sg__set(arg1,SWIG_STD_MOVE(arg2),(float const &)*arg3);
}


SWIGEXPORT float _wrap_FloatVector_get(SwigClassWrapper *farg1, size_t const *farg2) {
  float fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  float *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::get(std::vector< float >::size_type)", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = *farg2 - 1;
  result = (float *) &std_vector_Sl_float_Sg__get(arg1,SWIG_STD_MOVE(arg2));
  fresult = *result;
  return fresult;
}


SWIGEXPORT void _wrap_FloatVector_insert(SwigClassWrapper *farg1, size_t const *farg2, float const *farg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  float *arg3 = 0 ;
  float temp3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::insert(std::vector< float >::size_type,float const &)", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = *farg2 - 1;
  temp3 = (float)(*farg3);
  arg3 = &temp3;
  std_vector_Sl_float_Sg__insert(arg1,SWIG_STD_MOVE(arg2),(float const &)*arg3);
}


SWIGEXPORT void _wrap_FloatVector_erase__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::erase(std::vector< float >::size_type)", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = *farg2 - 1;
  std_vector_Sl_float_Sg__erase__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
}


SWIGEXPORT void _wrap_FloatVector_erase__SWIG_1(SwigClassWrapper *farg1, size_t const *farg2, size_t const *farg3) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  std::vector< float >::size_type arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::erase(std::vector< float >::size_type,std::vector< float >::size_type)", return );
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = *farg2 - 1;
  arg3 = *farg3 - 1;
  std_vector_Sl_float_Sg__erase__SWIG_1(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
}


SWIGEXPORT float * _wrap_FloatVector_front_ref(SwigClassWrapper *farg1) {
  float * fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::front_ref()", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  result = (float *) &std_vector_Sl_float_Sg__front_ref(arg1);
  fresult = result;
  return fresult;
}


SWIGEXPORT float * _wrap_FloatVector_back_ref(SwigClassWrapper *farg1) {
  float * fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  float *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::back_ref()", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  result = (float *) &std_vector_Sl_float_Sg__back_ref(arg1);
  fresult = result;
  return fresult;
}


SWIGEXPORT float * _wrap_FloatVector_get_ref(SwigClassWrapper *farg1, size_t const *farg2) {
  float * fresult ;
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  float *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< float > *", "FloatVector", "std::vector< float >::get_ref(std::vector< float >::size_type)", return 0);
  arg1 = (std::vector< float > *)farg1->cptr;
  arg2 = *farg2 - 1;
  result = (float *) &std_vector_Sl_float_Sg__get_ref(arg1,SWIG_STD_MOVE(arg2));
  fresult = result;
  return fresult;
}


SWIGEXPORT void _wrap_delete_FloatVector(SwigClassWrapper *farg1) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  
  arg1 = (std::vector< float > *)farg1->cptr;
  delete arg1;
}


SWIGEXPORT void _wrap_FloatVector_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float > *arg2 = 0 ;
  
  (void)sizeof(arg1);
  (void)sizeof(arg2);
  SWIG_assign<std::vector< float >, SWIGPOLICY_std_vector_Sl__Sp_float_SP__Sg_>(farg1, *farg2);
  
}


SWIGEXPORT SwigClassWrapper _wrap_new_MeasurementVector__SWIG_0() {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement > *result = 0 ;
  
  result = (std::vector< SpecUtils::Measurement > *)new std::vector< SpecUtils::Measurement >();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_MeasurementVector__SWIG_1(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = 0 ;
  std::vector< SpecUtils::Measurement > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > const &", "MeasurementVector", "std::vector< SpecUtils::Measurement >::vector(std::vector< SpecUtils::Measurement > const &)", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  result = (std::vector< SpecUtils::Measurement > *)new std::vector< SpecUtils::Measurement >((std::vector< SpecUtils::Measurement > const &)*arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_MeasurementVector__SWIG_2(size_t const *farg1) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement >::size_type arg1 ;
  std::vector< SpecUtils::Measurement > *result = 0 ;
  
  arg1 = (std::vector< SpecUtils::Measurement >::size_type)(*farg1);
  result = (std::vector< SpecUtils::Measurement > *)new std::vector< SpecUtils::Measurement >(arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_MeasurementVector__SWIG_3(size_t const *farg1, SwigClassWrapper *farg2) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement >::size_type arg1 ;
  SpecUtils::Measurement *arg2 = 0 ;
  std::vector< SpecUtils::Measurement > *result = 0 ;
  
  arg1 = (std::vector< SpecUtils::Measurement >::size_type)(*farg1);
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::Measurement const &", "Measurement", "std::vector< SpecUtils::Measurement >::vector(std::vector< SpecUtils::Measurement >::size_type,SpecUtils::Measurement const &)", return SwigClassWrapper_uninitialized());
  arg2 = (SpecUtils::Measurement *)farg2->cptr;
  result = (std::vector< SpecUtils::Measurement > *)new std::vector< SpecUtils::Measurement >(arg1,(SpecUtils::Measurement const &)*arg2);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT size_t _wrap_MeasurementVector_size(SwigClassWrapper *farg1) {
  size_t fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > const *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::size() const", return 0);
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  result = ((std::vector< SpecUtils::Measurement > const *)arg1)->size();
  fresult = (std::vector< SpecUtils::Measurement >::size_type)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_MeasurementVector_capacity(SwigClassWrapper *farg1) {
  size_t fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > const *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::capacity() const", return 0);
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  result = ((std::vector< SpecUtils::Measurement > const *)arg1)->capacity();
  fresult = (std::vector< SpecUtils::Measurement >::size_type)(result);
  return fresult;
}


SWIGEXPORT int _wrap_MeasurementVector_empty(SwigClassWrapper *farg1) {
  int fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > const *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::empty() const", return 0);
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  result = (bool)((std::vector< SpecUtils::Measurement > const *)arg1)->empty();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_MeasurementVector_front(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  SpecUtils::Measurement *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > const *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::front() const", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  result = (SpecUtils::Measurement *) &((std::vector< SpecUtils::Measurement > const *)arg1)->front();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_MeasurementVector_back(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  SpecUtils::Measurement *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > const *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::back() const", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  result = (SpecUtils::Measurement *) &((std::vector< SpecUtils::Measurement > const *)arg1)->back();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_MeasurementVector_reserve(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::reserve(std::vector< SpecUtils::Measurement >::size_type)", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = (std::vector< SpecUtils::Measurement >::size_type)(*farg2);
  (arg1)->reserve(arg2);
}


SWIGEXPORT void _wrap_MeasurementVector_resize__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::resize(std::vector< SpecUtils::Measurement >::size_type)", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = (std::vector< SpecUtils::Measurement >::size_type)(*farg2);
  (arg1)->resize(arg2);
}


SWIGEXPORT void _wrap_MeasurementVector_resize__SWIG_1(SwigClassWrapper *farg1, size_t const *farg2, SwigClassWrapper *farg3) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  SpecUtils::Measurement *arg3 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::resize(std::vector< SpecUtils::Measurement >::size_type,SpecUtils::Measurement const &)", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = (std::vector< SpecUtils::Measurement >::size_type)(*farg2);
  SWIG_check_nonnull(farg3->cptr, "SpecUtils::Measurement const &", "Measurement", "std::vector< SpecUtils::Measurement >::resize(std::vector< SpecUtils::Measurement >::size_type,SpecUtils::Measurement const &)", return );
  arg3 = (SpecUtils::Measurement *)farg3->cptr;
  (arg1)->resize(arg2,(SpecUtils::Measurement const &)*arg3);
}


SWIGEXPORT void _wrap_MeasurementVector_push_back(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  SpecUtils::Measurement *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::push_back(SpecUtils::Measurement const &)", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::Measurement const &", "Measurement", "std::vector< SpecUtils::Measurement >::push_back(SpecUtils::Measurement const &)", return );
  arg2 = (SpecUtils::Measurement *)farg2->cptr;
  (arg1)->push_back((SpecUtils::Measurement const &)*arg2);
}


SWIGEXPORT void _wrap_MeasurementVector_pop_back(SwigClassWrapper *farg1) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::pop_back()", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  (arg1)->pop_back();
}


SWIGEXPORT void _wrap_MeasurementVector_clear(SwigClassWrapper *farg1) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::clear()", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  (arg1)->clear();
}


SWIGEXPORT void _wrap_MeasurementVector_set(SwigClassWrapper *farg1, size_t const *farg2, SwigClassWrapper *farg3) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  SpecUtils::Measurement *arg3 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::set(std::vector< SpecUtils::Measurement >::size_type,SpecUtils::Measurement const &)", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = *farg2 - 1;
  SWIG_check_nonnull(farg3->cptr, "SpecUtils::Measurement const &", "Measurement", "std::vector< SpecUtils::Measurement >::set(std::vector< SpecUtils::Measurement >::size_type,SpecUtils::Measurement const &)", return );
  arg3 = (SpecUtils::Measurement *)farg3->cptr;
  std_vector_Sl_SpecUtils_Measurement_Sg__set(arg1,SWIG_STD_MOVE(arg2),(SpecUtils::Measurement const &)*arg3);
}


SWIGEXPORT SwigClassWrapper _wrap_MeasurementVector_get(SwigClassWrapper *farg1, size_t const *farg2) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  SpecUtils::Measurement *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::get(std::vector< SpecUtils::Measurement >::size_type)", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = *farg2 - 1;
  result = (SpecUtils::Measurement *) &std_vector_Sl_SpecUtils_Measurement_Sg__get(arg1,SWIG_STD_MOVE(arg2));
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_MeasurementVector_insert(SwigClassWrapper *farg1, size_t const *farg2, SwigClassWrapper *farg3) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  SpecUtils::Measurement *arg3 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::insert(std::vector< SpecUtils::Measurement >::size_type,SpecUtils::Measurement const &)", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = *farg2 - 1;
  SWIG_check_nonnull(farg3->cptr, "SpecUtils::Measurement const &", "Measurement", "std::vector< SpecUtils::Measurement >::insert(std::vector< SpecUtils::Measurement >::size_type,SpecUtils::Measurement const &)", return );
  arg3 = (SpecUtils::Measurement *)farg3->cptr;
  std_vector_Sl_SpecUtils_Measurement_Sg__insert(arg1,SWIG_STD_MOVE(arg2),(SpecUtils::Measurement const &)*arg3);
}


SWIGEXPORT void _wrap_MeasurementVector_erase__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::erase(std::vector< SpecUtils::Measurement >::size_type)", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = *farg2 - 1;
  std_vector_Sl_SpecUtils_Measurement_Sg__erase__SWIG_0(arg1,SWIG_STD_MOVE(arg2));
}


SWIGEXPORT void _wrap_MeasurementVector_erase__SWIG_1(SwigClassWrapper *farg1, size_t const *farg2, size_t const *farg3) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  std::vector< SpecUtils::Measurement >::size_type arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::erase(std::vector< SpecUtils::Measurement >::size_type,std::vector< SpecUtils::Measurement >::size_type)", return );
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = *farg2 - 1;
  arg3 = *farg3 - 1;
  std_vector_Sl_SpecUtils_Measurement_Sg__erase__SWIG_1(arg1,SWIG_STD_MOVE(arg2),SWIG_STD_MOVE(arg3));
}


SWIGEXPORT SwigClassWrapper _wrap_MeasurementVector_front_ref(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  SpecUtils::Measurement *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::front_ref()", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  result = (SpecUtils::Measurement *) &std_vector_Sl_SpecUtils_Measurement_Sg__front_ref(arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_MeasurementVector_back_ref(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  SpecUtils::Measurement *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::back_ref()", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  result = (SpecUtils::Measurement *) &std_vector_Sl_SpecUtils_Measurement_Sg__back_ref(arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_MeasurementVector_get_ref(SwigClassWrapper *farg1, size_t const *farg2) {
  SwigClassWrapper fresult ;
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement >::size_type arg2 ;
  SpecUtils::Measurement *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "std::vector< SpecUtils::Measurement > *", "MeasurementVector", "std::vector< SpecUtils::Measurement >::get_ref(std::vector< SpecUtils::Measurement >::size_type)", return SwigClassWrapper_uninitialized());
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  arg2 = *farg2 - 1;
  result = (SpecUtils::Measurement *) &std_vector_Sl_SpecUtils_Measurement_Sg__get_ref(arg1,SWIG_STD_MOVE(arg2));
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_delete_MeasurementVector(SwigClassWrapper *farg1) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  
  arg1 = (std::vector< SpecUtils::Measurement > *)farg1->cptr;
  delete arg1;
}


SWIGEXPORT void _wrap_MeasurementVector_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  std::vector< SpecUtils::Measurement > *arg1 = (std::vector< SpecUtils::Measurement > *) 0 ;
  std::vector< SpecUtils::Measurement > *arg2 = 0 ;
  
  (void)sizeof(arg1);
  (void)sizeof(arg2);
  SWIG_assign<std::vector< SpecUtils::Measurement >, SWIGPOLICY_std_vector_Sl__Sp_SpecUtils_Measurement_SP__Sg_>(farg1, *farg2);
  
}


SWIGEXPORT int _wrap_spectrumTypeFromDescription(SwigArrayWrapper *farg1) {
  int fresult ;
  char *arg1 = (char *) 0 ;
  SpecUtils::SpectrumType result;
  
  arg1 = (char *)(farg1->data);
  result = (SpecUtils::SpectrumType)SpecUtils::spectrumTypeFromDescription((char const *)arg1);
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_suggestedNameEnding(int const *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SaveSpectrumAsType arg1 ;
  char *result = 0 ;
  
  arg1 = (SpecUtils::SaveSpectrumAsType)(*farg1);
  result = (char *)SpecUtils::suggestedNameEnding(arg1);
  fresult.size = strlen((char*)(result));
  fresult.data = const_cast< char * >(result);
  return fresult;
}


SWIGEXPORT int _wrap_is_candidate_n42_file__SWIG_0(SwigArrayWrapper *farg1) {
  int fresult ;
  char *arg1 = (char *) 0 ;
  bool result;
  
  arg1 = (char *)(farg1->data);
  result = (bool)SpecUtils::is_candidate_n42_file((char const *)arg1);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_is_candidate_n42_file__SWIG_1(SwigArrayWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  char *arg1 = (char *) (char *)0 ;
  char *arg2 = (char *) (char *)0 ;
  bool result;
  
  arg1 = (char *)(farg1->data);
  arg2 = (char *)(farg2->data);
  result = (bool)SpecUtils::is_candidate_n42_file((char const *)arg1,(char const *)arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_convert_n42_utf16_xml_to_utf8(SwigArrayWrapper *farg1, SwigArrayWrapper *farg2) {
  SwigArrayWrapper fresult ;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) (char *)0 ;
  char *result = 0 ;
  
  arg1 = (char *)(farg1->data);
  arg2 = (char *)(farg2->data);
  result = (char *)SpecUtils::convert_n42_utf16_xml_to_utf8(arg1,arg2);
  fresult.size = strlen((char*)(result));
  fresult.data = const_cast< char * >(result);
  return fresult;
}


SWIGEXPORT void _wrap_add_analysis_results_to_2012_N42(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3) {
  SpecUtils::DetectorAnalysis *arg1 = 0 ;
  ::rapidxml::xml_node< char > *arg2 = (::rapidxml::xml_node< char > *) 0 ;
  std::mutex *arg3 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis const &", "DetectorAnalysis", "SpecUtils::add_analysis_results_to_2012_N42(SpecUtils::DetectorAnalysis const &,::rapidxml::xml_node< char > *,std::mutex &)", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  arg2 = (::rapidxml::xml_node< char > *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::mutex &", "SWIGTYPE_p_std__mutex", "SpecUtils::add_analysis_results_to_2012_N42(SpecUtils::DetectorAnalysis const &,::rapidxml::xml_node< char > *,std::mutex &)", return );
  arg3 = (std::mutex *)farg3->cptr;
  SpecUtils::add_analysis_results_to_2012_N42((SpecUtils::DetectorAnalysis const &)*arg1,arg2,*arg3);
}


SWIGEXPORT void _wrap_set_analysis_info_from_n42(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  rapidxml::xml_node< char > *arg1 = (rapidxml::xml_node< char > *) 0 ;
  SpecUtils::DetectorAnalysis *arg2 = 0 ;
  
  arg1 = (rapidxml::xml_node< char > *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::DetectorAnalysis &", "DetectorAnalysis", "SpecUtils::set_analysis_info_from_n42(rapidxml::xml_node< char > const *,SpecUtils::DetectorAnalysis &)", return );
  arg2 = (SpecUtils::DetectorAnalysis *)farg2->cptr;
  SpecUtils::set_analysis_info_from_n42((rapidxml::xml_node< char > const *)arg1,*arg2);
}


SWIGEXPORT double _wrap_gamma_integral(SwigClassWrapper const *farg1, float const *farg2, float const *farg3) {
  double fresult ;
  std::shared_ptr< SpecUtils::Measurement const > *arg1 = 0 ;
  float arg2 ;
  float arg3 ;
  std::shared_ptr< SpecUtils::Measurement const > tempnull1 ;
  double result;
  
  arg1 = farg1->cptr ? static_cast<std::shared_ptr< SpecUtils::Measurement const > * >(farg1->cptr) : &tempnull1;
  arg2 = (float)(*farg2);
  arg3 = (float)(*farg3);
  result = (double)SpecUtils::gamma_integral((std::shared_ptr< SpecUtils::Measurement const > const &)*arg1,arg2,arg3);
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_detectorTypeToString(int const *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorType arg1 ;
  std::string *result = 0 ;
  
  arg1 = (SpecUtils::DetectorType)(*farg1);
  result = (std::string *) &SpecUtils::detectorTypeToString(arg1);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_Measurement() {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *result = 0 ;
  
  result = (SpecUtils::Measurement *)new SpecUtils::Measurement();
  fresult.cptr = result ? new std::shared_ptr< SpecUtils::Measurement >(result SWIG_NO_NULL_DELETER_1) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT size_t _wrap_Measurement_memmorysize(SwigClassWrapper *farg1) {
  size_t fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  size_t result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = ((SpecUtils::Measurement const *)arg1)->memmorysize();
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_live_time(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->live_time();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_real_time(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->real_time();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_contained_neutron(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  bool result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (bool)((SpecUtils::Measurement const *)arg1)->contained_neutron();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_sample_number(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  int result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (int)((SpecUtils::Measurement const *)arg1)->sample_number();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_Measurement_title(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::string *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::string *) &((SpecUtils::Measurement const *)arg1)->title();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_occupied(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  SpecUtils::OccupancyStatus result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (SpecUtils::OccupancyStatus)((SpecUtils::Measurement const *)arg1)->occupied();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT double _wrap_Measurement_gamma_count_sum(SwigClassWrapper *farg1) {
  double fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  double result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (double)((SpecUtils::Measurement const *)arg1)->gamma_count_sum();
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_neutron_live_time(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->neutron_live_time();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT double _wrap_Measurement_neutron_counts_sum(SwigClassWrapper *farg1) {
  double fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  double result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (double)((SpecUtils::Measurement const *)arg1)->neutron_counts_sum();
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_speed(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->speed();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_dx(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->dx();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_dy(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->dy();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT double _wrap_Measurement_latitude(SwigClassWrapper *farg1) {
  double fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  double result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (double)((SpecUtils::Measurement const *)arg1)->latitude();
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT double _wrap_Measurement_longitude(SwigClassWrapper *farg1) {
  double fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  double result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (double)((SpecUtils::Measurement const *)arg1)->longitude();
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_has_gps_info(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  bool result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (bool)((SpecUtils::Measurement const *)arg1)->has_gps_info();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_dose_rate(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->dose_rate();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_exposure_rate(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->exposure_rate();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_position_time(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  SpecUtils::time_point_t result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = ((SpecUtils::Measurement const *)arg1)->position_time();
  fresult.cptr = new (SpecUtils::time_point_t)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_Measurement_detector_name(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::string *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::string *) &((SpecUtils::Measurement const *)arg1)->detector_name();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_detector_number(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  int result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (int)((SpecUtils::Measurement const *)arg1)->detector_number();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_Measurement_detector_type(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::string *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::string *) &((SpecUtils::Measurement const *)arg1)->detector_type();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_quality_status(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  SpecUtils::QualityStatus result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (SpecUtils::QualityStatus)((SpecUtils::Measurement const *)arg1)->quality_status();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_source_type(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  SpecUtils::SourceType result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (SpecUtils::SourceType)((SpecUtils::Measurement const *)arg1)->source_type();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_remarks(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::vector< std::string > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::vector< std::string > *) &((SpecUtils::Measurement const *)arg1)->remarks();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_parse_warnings(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::vector< std::string > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::vector< std::string > *) &((SpecUtils::Measurement const *)arg1)->parse_warnings();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_start_time(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  SpecUtils::time_point_t *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (SpecUtils::time_point_t *) &((SpecUtils::Measurement const *)arg1)->start_time();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_start_time_copy(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  SpecUtils::time_point_t result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = ((SpecUtils::Measurement const *)arg1)->start_time_copy();
  fresult.cptr = new (SpecUtils::time_point_t)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_energy_calibration_model(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  SpecUtils::EnergyCalType result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (SpecUtils::EnergyCalType)((SpecUtils::Measurement const *)arg1)->energy_calibration_model();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_calibration_coeffs(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::vector< float > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::vector< float > *) &((SpecUtils::Measurement const *)arg1)->calibration_coeffs();
  {
    fresult.cptr = new std::shared_ptr<const std::vector<float> >(result SWIG_NO_NULL_DELETER_0);
    fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_deviation_pairs(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::vector< std::pair< float,float > > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::vector< std::pair< float,float > > *) &((SpecUtils::Measurement const *)arg1)->deviation_pairs();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_energy_calibration(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  SwigValueWrapper< std::shared_ptr< SpecUtils::EnergyCalibration const > > result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = ((SpecUtils::Measurement const *)arg1)->energy_calibration();
  fresult.cptr = new (std::shared_ptr< SpecUtils::EnergyCalibration const >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_channel_energies(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::shared_ptr< std::vector< float > const > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::shared_ptr< std::vector< float > const > *) &((SpecUtils::Measurement const *)arg1)->channel_energies();
  fresult.cptr = *result ? (new std::shared_ptr<const std::vector<float> >(static_cast< const std::shared_ptr<const std::vector<float> >& >(*result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_gamma_counts(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::shared_ptr< std::vector< float > const > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::shared_ptr< std::vector< float > const > *) &((SpecUtils::Measurement const *)arg1)->gamma_counts();
  fresult.cptr = *result ? (new std::shared_ptr<const std::vector<float> >(static_cast< const std::shared_ptr<const std::vector<float> >& >(*result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_neutron_counts(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::vector< float > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::vector< float > *) &((SpecUtils::Measurement const *)arg1)->neutron_counts();
  {
    fresult.cptr = new std::shared_ptr<const std::vector<float> >(result SWIG_NO_NULL_DELETER_0);
    fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_location_state(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::shared_ptr< SpecUtils::LocationState const > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::shared_ptr< SpecUtils::LocationState const > *) &((SpecUtils::Measurement const *)arg1)->location_state();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_Measurement_set_title(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::string *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  std::string tempstr2 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_title((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_Measurement_set_start_time(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  SpecUtils::time_point_t *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::time_point_t const &", "SWIGTYPE_p_std__chrono__time_pointT_std__chrono__system_c1Q0CUN", "SpecUtils::Measurement::set_start_time(SpecUtils::time_point_t const &)", return );
  arg2 = (SpecUtils::time_point_t *)farg2->cptr;
  (arg1)->set_start_time((SpecUtils::time_point_t const &)*arg2);
}


SWIGEXPORT void _wrap_Measurement_set_remarks(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::Measurement::set_remarks(std::vector< std::string > const &)", return );
  arg2 = (std::vector< std::string > *)farg2->cptr;
  (arg1)->set_remarks((std::vector< std::string > const &)*arg2);
}


SWIGEXPORT void _wrap_Measurement_set_parse_warnings(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::Measurement::set_parse_warnings(std::vector< std::string > const &)", return );
  arg2 = (std::vector< std::string > *)farg2->cptr;
  (arg1)->set_parse_warnings((std::vector< std::string > const &)*arg2);
}


SWIGEXPORT void _wrap_Measurement_set_source_type(SwigClassWrapper *farg1, int const *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  SpecUtils::SourceType arg2 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (SpecUtils::SourceType)(*farg2);
  (arg1)->set_source_type(arg2);
}


SWIGEXPORT void _wrap_Measurement_set_position(SwigClassWrapper *farg1, double const *farg2, double const *farg3, SwigClassWrapper *farg4) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  double arg2 ;
  double arg3 ;
  SpecUtils::time_point_t arg4 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (double)(*farg2);
  arg3 = (double)(*farg3);
  SWIG_check_nonnull(farg4->cptr, "SpecUtils::time_point_t", "SWIGTYPE_p_std__chrono__time_pointT_std__chrono__system_c1Q0CUN", "SpecUtils::Measurement::set_position(double,double,SpecUtils::time_point_t)", return );
  arg4 = *((SpecUtils::time_point_t *)(farg4->cptr));
  (arg1)->set_position(arg2,arg3,arg4);
}


SWIGEXPORT void _wrap_Measurement_set_sample_number(SwigClassWrapper *farg1, int const *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  int arg2 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (int)(*farg2);
  (arg1)->set_sample_number(arg2);
}


SWIGEXPORT void _wrap_Measurement_set_occupancy_status(SwigClassWrapper *farg1, int const *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  SpecUtils::OccupancyStatus arg2 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (SpecUtils::OccupancyStatus)(*farg2);
  (arg1)->set_occupancy_status(arg2);
}


SWIGEXPORT void _wrap_Measurement_set_detector_name(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::string *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  std::string tempstr2 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_detector_name((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_Measurement_set_detector_number(SwigClassWrapper *farg1, int const *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  int arg2 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (int)(*farg2);
  (arg1)->set_detector_number(arg2);
}


SWIGEXPORT void _wrap_Measurement_set_gamma_counts(SwigClassWrapper *farg1, SwigClassWrapper const *farg2, float const *farg3, float const *farg4) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< std::vector< float > const > arg2 ;
  float arg3 ;
  float arg4 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  if (farg2->cptr) arg2 = *static_cast<std::shared_ptr<const std::vector<float> >*>(farg2->cptr);
  arg3 = (float)(*farg3);
  arg4 = (float)(*farg4);
  (arg1)->set_gamma_counts(arg2,arg3,arg4);
}


SWIGEXPORT void _wrap_Measurement_set_neutron_counts(SwigClassWrapper *farg1, SwigClassWrapper *farg2, float const *farg3) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::vector< float > *arg2 = 0 ;
  float arg3 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_sp_nonnull(farg2->cptr, "std::vector< float > *", "FloatVector", "SpecUtils::Measurement::set_neutron_counts(std::vector< float > const &,float const)", return )
  arg2 = (std::vector<float>*)static_cast<std::shared_ptr<const std::vector<float> >*>(farg2->cptr)->get();
  arg3 = (float)(*farg3);
  (arg1)->set_neutron_counts((std::vector< float > const &)*arg2,arg3);
}


SWIGEXPORT size_t _wrap_Measurement_num_gamma_channels(SwigClassWrapper *farg1) {
  size_t fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  size_t result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = ((SpecUtils::Measurement const *)arg1)->num_gamma_channels();
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_Measurement_find_gamma_channel(SwigClassWrapper *farg1, float const *farg2) {
  size_t fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  float arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  size_t result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (float)(*farg2);
  result = ((SpecUtils::Measurement const *)arg1)->find_gamma_channel(arg2);
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_gamma_channel_content(SwigClassWrapper *farg1, size_t const *farg2) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  size_t arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (size_t)(*farg2);
  result = (float)((SpecUtils::Measurement const *)arg1)->gamma_channel_content(arg2);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_gamma_channel_lower(SwigClassWrapper *farg1, size_t const *farg2) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  size_t arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (size_t)(*farg2);
  result = (float)((SpecUtils::Measurement const *)arg1)->gamma_channel_lower(arg2);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_gamma_channel_center(SwigClassWrapper *farg1, size_t const *farg2) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  size_t arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (size_t)(*farg2);
  result = (float)((SpecUtils::Measurement const *)arg1)->gamma_channel_center(arg2);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_gamma_channel_upper(SwigClassWrapper *farg1, size_t const *farg2) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  size_t arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (size_t)(*farg2);
  result = (float)((SpecUtils::Measurement const *)arg1)->gamma_channel_upper(arg2);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_gamma_channel_width(SwigClassWrapper *farg1, size_t const *farg2) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  size_t arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (size_t)(*farg2);
  result = (float)((SpecUtils::Measurement const *)arg1)->gamma_channel_width(arg2);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT double _wrap_Measurement_gamma_integral(SwigClassWrapper *farg1, float const *farg2, float const *farg3) {
  double fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  float arg2 ;
  float arg3 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  double result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (float)(*farg2);
  arg3 = (float)(*farg3);
  result = (double)((SpecUtils::Measurement const *)arg1)->gamma_integral(arg2,arg3);
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT double _wrap_Measurement_gamma_channels_sum(SwigClassWrapper *farg1, size_t const *farg2, size_t const *farg3) {
  double fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  double result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (size_t)(*farg2);
  arg3 = (size_t)(*farg3);
  result = (double)((SpecUtils::Measurement const *)arg1)->gamma_channels_sum(arg2,arg3);
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_gamma_channel_energies(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::shared_ptr< std::vector< float > const > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::shared_ptr< std::vector< float > const > *) &((SpecUtils::Measurement const *)arg1)->gamma_channel_energies();
  fresult.cptr = *result ? (new std::shared_ptr<const std::vector<float> >(static_cast< const std::shared_ptr<const std::vector<float> >& >(*result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_Measurement_gamma_channel_contents(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  std::shared_ptr< std::vector< float > const > *result = 0 ;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (std::shared_ptr< std::vector< float > const > *) &((SpecUtils::Measurement const *)arg1)->gamma_channel_contents();
  fresult.cptr = *result ? (new std::shared_ptr<const std::vector<float> >(static_cast< const std::shared_ptr<const std::vector<float> >& >(*result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_gamma_energy_min(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->gamma_energy_min();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_Measurement_gamma_energy_max(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = (float)((SpecUtils::Measurement const *)arg1)->gamma_energy_max();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT SWIGEXTERN const int _wrap_Measurement_DerivedDataProperties_IsDerived = (int)(SpecUtils::Measurement::DerivedDataProperties::IsDerived);

SWIGEXPORT SWIGEXTERN const int _wrap_Measurement_DerivedDataProperties_ItemOfInterestSum = (int)(SpecUtils::Measurement::DerivedDataProperties::ItemOfInterestSum);

SWIGEXPORT SWIGEXTERN const int _wrap_Measurement_DerivedDataProperties_UsedForAnalysis = (int)(SpecUtils::Measurement::DerivedDataProperties::UsedForAnalysis);

SWIGEXPORT SWIGEXTERN const int _wrap_Measurement_DerivedDataProperties_ProcessedFurther = (int)(SpecUtils::Measurement::DerivedDataProperties::ProcessedFurther);

SWIGEXPORT SWIGEXTERN const int _wrap_Measurement_DerivedDataProperties_BackgroundSubtracted = (int)(SpecUtils::Measurement::DerivedDataProperties::BackgroundSubtracted);

SWIGEXPORT SWIGEXTERN const int _wrap_Measurement_DerivedDataProperties_IsBackground = (int)(SpecUtils::Measurement::DerivedDataProperties::IsBackground);

SWIGEXPORT SwigClassWrapper _wrap_Measurement_derived_data_properties(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  uint32_t result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  result = ((SpecUtils::Measurement const *)arg1)->derived_data_properties();
  fresult.cptr = new (uint32_t)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_write_2006_N42_xml(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::ostream *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  bool result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::Measurement::write_2006_N42_xml(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::Measurement const *)arg1)->write_2006_N42_xml(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_write_csv(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::ostream *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  bool result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::Measurement::write_csv(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::Measurement const *)arg1)->write_csv(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_Measurement_write_txt(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::ostream *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *smartarg1 ;
  bool result;
  
  smartarg1 = (std::shared_ptr<const SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::Measurement::write_txt(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::Measurement const *)arg1)->write_txt(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT void _wrap_Measurement_reset(SwigClassWrapper *farg1) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  (arg1)->reset();
}


SWIGEXPORT void _wrap_Measurement_rebin(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::EnergyCalibration const > *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_nonnull(farg2->cptr, "std::shared_ptr< SpecUtils::EnergyCalibration const > const &", "SWIGTYPE_p_std__shared_ptrT_SpecUtils__EnergyCalibration_cYBZ7Z", "SpecUtils::Measurement::rebin(std::shared_ptr< SpecUtils::EnergyCalibration const > const &)", return );
  arg2 = (std::shared_ptr< SpecUtils::EnergyCalibration const > *)farg2->cptr;
  (arg1)->rebin((std::shared_ptr< SpecUtils::EnergyCalibration const > const &)*arg2);
}


SWIGEXPORT void _wrap_Measurement_set_info_from_2006_N42_spectrum_node(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  rapidxml::xml_node< char > *arg2 = (rapidxml::xml_node< char > *) (rapidxml::xml_node< char > *)0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  SWIG_check_nonnull(farg2->cptr, "rapidxml::xml_node< char > *", "SWIGTYPE_p_p_rapidxml__xml_nodeT_char_t", "SpecUtils::Measurement::set_info_from_2006_N42_spectrum_node(rapidxml::xml_node< char > const *const)", return );
  arg2 = *((rapidxml::xml_node< char > **)(farg2->cptr));
  (arg1)->set_info_from_2006_N42_spectrum_node((rapidxml::xml_node< char > const *)arg2);
}


SWIGEXPORT float _wrap_Measurement_gamma_count_at(SwigClassWrapper *farg1, int const *farg2) {
  float fresult ;
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  int arg2 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  float result;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  arg2 = (int)(*farg2);
  result = (float)SpecUtils_Measurement_gamma_count_at(arg1,arg2);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT void _wrap_delete_Measurement(SwigClassWrapper *farg1) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  (void)arg1; delete smartarg1; 
}


SWIGEXPORT void _wrap_Measurement_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::Measurement *arg1 = (SpecUtils::Measurement *) 0 ;
  SpecUtils::Measurement *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement > *smartarg1 ;
  
  smartarg1 = (std::shared_ptr< SpecUtils::Measurement >*)(farg1->cptr);
  arg1 = smartarg1 ? (SpecUtils::Measurement*)(smartarg1->get()) : NULL;
  (void)sizeof(arg2);
  SWIG_assign<std::shared_ptr< SpecUtils::Measurement >, SWIGPOLICY_SpecUtils_Measurement>(farg1, *farg2);
  
}


SWIGEXPORT SwigClassWrapper _wrap_new_SpecFile__SWIG_0() {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *result = 0 ;
  
  result = (SpecUtils::SpecFile *)new SpecUtils::SpecFile();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_SpecFile__SWIG_1(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = 0 ;
  SpecUtils::SpecFile *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const &", "SpecFile", "SpecUtils::SpecFile::SpecFile(SpecUtils::SpecFile const &)", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (SpecUtils::SpecFile *)new SpecUtils::SpecFile((SpecUtils::SpecFile const &)*arg1);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_delete_SpecFile(SwigClassWrapper *farg1) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  delete arg1;
}


SWIGEXPORT int _wrap_SpecFile_load_file__SWIG_0(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, int const *farg3, SwigArrayWrapper *farg4) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  SpecUtils::ParserType arg3 ;
  std::string arg4 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_file(std::string const &,SpecUtils::ParserType,std::string)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  arg3 = (SpecUtils::ParserType)(*farg3);
  (&arg4)->assign(static_cast<char *>(farg4->data), farg4->size);
  result = (bool)(arg1)->load_file((std::string const &)*arg2,arg3,arg4);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_file__SWIG_1(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, int const *farg3) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  SpecUtils::ParserType arg3 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_file(std::string const &,SpecUtils::ParserType)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  arg3 = (SpecUtils::ParserType)(*farg3);
  result = (bool)(arg1)->load_file((std::string const &)*arg2,arg3);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_parse_warnings(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::parse_warnings() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::vector< std::string > *) &((SpecUtils::SpecFile const *)arg1)->parse_warnings();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_modified(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::modified() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->modified();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT void _wrap_SpecFile_reset_modified(SwigClassWrapper *farg1) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::reset_modified()", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (arg1)->reset_modified();
}


SWIGEXPORT int _wrap_SpecFile_modified_since_decode(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::modified_since_decode() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->modified_since_decode();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT void _wrap_SpecFile_reset_modified_since_decode(SwigClassWrapper *farg1) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::reset_modified_since_decode()", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (arg1)->reset_modified_since_decode();
}


SWIGEXPORT float _wrap_SpecFile_gamma_live_time(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  float result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::gamma_live_time() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (float)((SpecUtils::SpecFile const *)arg1)->gamma_live_time();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT float _wrap_SpecFile_gamma_real_time(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  float result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::gamma_real_time() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (float)((SpecUtils::SpecFile const *)arg1)->gamma_real_time();
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT double _wrap_SpecFile_gamma_count_sum(SwigClassWrapper *farg1) {
  double fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  double result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::gamma_count_sum() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (double)((SpecUtils::SpecFile const *)arg1)->gamma_count_sum();
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT double _wrap_SpecFile_neutron_counts_sum(SwigClassWrapper *farg1) {
  double fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  double result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::neutron_counts_sum() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (double)((SpecUtils::SpecFile const *)arg1)->neutron_counts_sum();
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_filename(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::filename() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->filename();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_detector_names(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::detector_names() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::vector< std::string > *) &((SpecUtils::SpecFile const *)arg1)->detector_names();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_detector_numbers(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< int > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::detector_numbers() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::vector< int > *) &((SpecUtils::SpecFile const *)arg1)->detector_numbers();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_gamma_detector_names(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::gamma_detector_names() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::vector< std::string > *) &((SpecUtils::SpecFile const *)arg1)->gamma_detector_names();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_neutron_detector_names(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::neutron_detector_names() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::vector< std::string > *) &((SpecUtils::SpecFile const *)arg1)->neutron_detector_names();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_uuid(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::uuid() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->uuid();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_remarks(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::remarks() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::vector< std::string > *) &((SpecUtils::SpecFile const *)arg1)->remarks();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_lane_number(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  int result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::lane_number() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (int)((SpecUtils::SpecFile const *)arg1)->lane_number();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_measurement_location_name(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::measurement_location_name() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->measurement_location_name();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_inspection(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::inspection() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->inspection();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_measurement_operator(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::measurement_operator() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->measurement_operator();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_sample_numbers(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::set< int,std::less< int >,std::allocator< int > > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::sample_numbers() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::set< int,std::less< int >,std::allocator< int > > *) &((SpecUtils::SpecFile const *)arg1)->sample_numbers();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT size_t _wrap_SpecFile_num_measurements(SwigClassWrapper *farg1) {
  size_t fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  size_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::num_measurements() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->num_measurements();
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_detector_type(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SpecUtils::DetectorType result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::detector_type() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (SpecUtils::DetectorType)((SpecUtils::SpecFile const *)arg1)->detector_type();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_instrument_type(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::instrument_type() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->instrument_type();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_manufacturer(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::manufacturer() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->manufacturer();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_instrument_model(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::instrument_model() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->instrument_model();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_instrument_id(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::instrument_id() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::string *) &((SpecUtils::SpecFile const *)arg1)->instrument_id();
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_measurements(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SwigValueWrapper< std::vector< std::shared_ptr< SpecUtils::Measurement const > > > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::measurements() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->measurements();
  fresult.cptr = new (std::vector< std::shared_ptr< SpecUtils::Measurement const > >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_measurement__SWIG_0(SwigClassWrapper *farg1, size_t const *farg2) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  size_t arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::measurement(size_t) const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (size_t)(*farg2);
  result = ((SpecUtils::SpecFile const *)arg1)->measurement(arg2);
  fresult.cptr = result ? (new std::shared_ptr<const SpecUtils::Measurement >(static_cast< const std::shared_ptr<const SpecUtils::Measurement >& >(result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_detectors_analysis(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SwigValueWrapper< std::shared_ptr< SpecUtils::DetectorAnalysis const > > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::detectors_analysis() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->detectors_analysis();
  fresult.cptr = new (std::shared_ptr< SpecUtils::DetectorAnalysis const >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_multimedia_data(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::shared_ptr< SpecUtils::MultimediaData const > > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::multimedia_data() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::vector< std::shared_ptr< SpecUtils::MultimediaData const > > *) &((SpecUtils::SpecFile const *)arg1)->multimedia_data();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_has_gps_info(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::has_gps_info() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->has_gps_info();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT double _wrap_SpecFile_mean_latitude(SwigClassWrapper *farg1) {
  double fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  double result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::mean_latitude() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (double)((SpecUtils::SpecFile const *)arg1)->mean_latitude();
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT double _wrap_SpecFile_mean_longitude(SwigClassWrapper *farg1) {
  double fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  double result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::mean_longitude() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (double)((SpecUtils::SpecFile const *)arg1)->mean_longitude();
  fresult = (double)(result);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_passthrough(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::passthrough() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->passthrough();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_contains_derived_data(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::contains_derived_data() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->contains_derived_data();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_contains_non_derived_data(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::contains_non_derived_data() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->contains_non_derived_data();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT void _wrap_SpecFile_set_filename(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_filename(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_filename((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_remarks__SWIG_0(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_remarks(std::vector< std::string > const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::set_remarks(std::vector< std::string > const &)", return );
  arg2 = (std::vector< std::string > *)farg2->cptr;
  (arg1)->set_remarks((std::vector< std::string > const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_add_remark(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::add_remark(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->add_remark((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_parse_warnings(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_parse_warnings(std::vector< std::string > const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::set_parse_warnings(std::vector< std::string > const &)", return );
  arg2 = (std::vector< std::string > *)farg2->cptr;
  (arg1)->set_parse_warnings((std::vector< std::string > const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_uuid(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_uuid(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_uuid((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_lane_number(SwigClassWrapper *farg1, int const *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  int arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_lane_number(int const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (int)(*farg2);
  (arg1)->set_lane_number(arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_measurement_location_name(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_measurement_location_name(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_measurement_location_name((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_inspection(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_inspection(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_inspection((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_instrument_type(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_instrument_type(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_instrument_type((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_detector_type(SwigClassWrapper *farg1, int const *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SpecUtils::DetectorType arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_detector_type(SpecUtils::DetectorType const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (SpecUtils::DetectorType)(*farg2);
  (arg1)->set_detector_type(arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_manufacturer(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_manufacturer(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_manufacturer((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_instrument_model(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_instrument_model(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_instrument_model((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_instrument_id(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_instrument_id(std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  (arg1)->set_instrument_id((std::string const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_live_time(SwigClassWrapper *farg1, float const *farg2, SwigClassWrapper const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  float arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_live_time(float const,std::shared_ptr< SpecUtils::Measurement const >)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (float)(*farg2);
  if (farg3->cptr) arg3 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg3->cptr);
  (arg1)->set_live_time(arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_set_real_time(SwigClassWrapper *farg1, float const *farg2, SwigClassWrapper const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  float arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_real_time(float const,std::shared_ptr< SpecUtils::Measurement const >)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (float)(*farg2);
  if (farg3->cptr) arg3 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg3->cptr);
  (arg1)->set_real_time(arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_set_start_time(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SpecUtils::time_point_t *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement const > arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_start_time(SpecUtils::time_point_t const &,std::shared_ptr< SpecUtils::Measurement const > const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::time_point_t const &", "SWIGTYPE_p_std__chrono__time_pointT_std__chrono__system_c1Q0CUN", "SpecUtils::SpecFile::set_start_time(SpecUtils::time_point_t const &,std::shared_ptr< SpecUtils::Measurement const > const)", return );
  arg2 = (SpecUtils::time_point_t *)farg2->cptr;
  if (farg3->cptr) arg3 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg3->cptr);
  (arg1)->set_start_time((SpecUtils::time_point_t const &)*arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_set_remarks__SWIG_1(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement const > arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_remarks(std::vector< std::string > const &,std::shared_ptr< SpecUtils::Measurement const > const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::set_remarks(std::vector< std::string > const &,std::shared_ptr< SpecUtils::Measurement const > const)", return );
  arg2 = (std::vector< std::string > *)farg2->cptr;
  if (farg3->cptr) arg3 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg3->cptr);
  (arg1)->set_remarks((std::vector< std::string > const &)*arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_set_source_type(SwigClassWrapper *farg1, int const *farg2, SwigClassWrapper const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SpecUtils::SourceType arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_source_type(SpecUtils::SourceType const,std::shared_ptr< SpecUtils::Measurement const > const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (SpecUtils::SourceType)(*farg2);
  if (farg3->cptr) arg3 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg3->cptr);
  (arg1)->set_source_type(arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_set_position(SwigClassWrapper *farg1, double const *farg2, double const *farg3, SwigClassWrapper *farg4, SwigClassWrapper const *farg5) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  double arg2 ;
  double arg3 ;
  SpecUtils::time_point_t arg4 ;
  std::shared_ptr< SpecUtils::Measurement const > arg5 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_position(double,double,SpecUtils::time_point_t,std::shared_ptr< SpecUtils::Measurement const > const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (double)(*farg2);
  arg3 = (double)(*farg3);
  SWIG_check_nonnull(farg4->cptr, "SpecUtils::time_point_t", "SWIGTYPE_p_std__chrono__time_pointT_std__chrono__system_c1Q0CUN", "SpecUtils::SpecFile::set_position(double,double,SpecUtils::time_point_t,std::shared_ptr< SpecUtils::Measurement const > const)", return );
  arg4 = *((SpecUtils::time_point_t *)(farg4->cptr));
  if (farg5->cptr) arg5 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg5->cptr);
  (arg1)->set_position(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void _wrap_SpecFile_set_title(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, SwigClassWrapper const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement const > arg3 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_title(std::string const &,std::shared_ptr< SpecUtils::Measurement const > const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (farg3->cptr) arg3 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg3->cptr);
  (arg1)->set_title((std::string const &)*arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_set_contained_neutrons(SwigClassWrapper *farg1, int const *farg2, float const *farg3, SwigClassWrapper const *farg4, float const *farg5) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  bool arg2 ;
  float arg3 ;
  std::shared_ptr< SpecUtils::Measurement const > arg4 ;
  float arg5 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_contained_neutrons(bool const,float const,std::shared_ptr< SpecUtils::Measurement const > const,float const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (*farg2 ? true : false);
  arg3 = (float)(*farg3);
  if (farg4->cptr) arg4 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg4->cptr);
  arg5 = (float)(*farg5);
  (arg1)->set_contained_neutrons(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void _wrap_SpecFile_set_detectors_analysis(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SpecUtils::DetectorAnalysis *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_detectors_analysis(SpecUtils::DetectorAnalysis const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::DetectorAnalysis const &", "DetectorAnalysis", "SpecUtils::SpecFile::set_detectors_analysis(SpecUtils::DetectorAnalysis const &)", return );
  arg2 = (SpecUtils::DetectorAnalysis *)farg2->cptr;
  (arg1)->set_detectors_analysis((SpecUtils::DetectorAnalysis const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_change_detector_name(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, SwigArrayWrapper *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string tempstr2 ;
  std::string tempstr3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::change_detector_name(std::string const &,std::string const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  tempstr3 = std::string(static_cast<char *>(farg3->data), farg3->size);
  arg3 = &tempstr3;
  (arg1)->change_detector_name((std::string const &)*arg2,(std::string const &)*arg3);
}


SWIGEXPORT void _wrap_SpecFile_change_sample_numbers(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::pair< int,int > > *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::change_sample_numbers(std::vector< std::pair< int,int > > const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::pair< int,int > > const &", "SWIGTYPE_p_std__vectorT_std__pairT_int_int_t_t", "SpecUtils::SpecFile::change_sample_numbers(std::vector< std::pair< int,int > > const &)", return );
  arg2 = (std::vector< std::pair< int,int > > *)farg2->cptr;
  (arg1)->change_sample_numbers((std::vector< std::pair< int,int > > const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_add_measurement(SwigClassWrapper *farg1, SwigClassWrapper const *farg2, int const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::shared_ptr< SpecUtils::Measurement > arg2 ;
  bool arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::add_measurement(std::shared_ptr< SpecUtils::Measurement >,bool const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  if (farg2->cptr) arg2 = *static_cast<std::shared_ptr< SpecUtils::Measurement >*>(farg2->cptr);
  arg3 = (*farg3 ? true : false);
  (arg1)->add_measurement(arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_remove_measurement(SwigClassWrapper *farg1, SwigClassWrapper const *farg2, int const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::shared_ptr< SpecUtils::Measurement const > arg2 ;
  bool arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::remove_measurement(std::shared_ptr< SpecUtils::Measurement const >,bool const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  if (farg2->cptr) arg2 = *static_cast<std::shared_ptr<const SpecUtils::Measurement >*>(farg2->cptr);
  arg3 = (*farg3 ? true : false);
  (arg1)->remove_measurement(arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_remove_measurements(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::shared_ptr< SpecUtils::Measurement const > > *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::remove_measurements(std::vector< std::shared_ptr< SpecUtils::Measurement const > > const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::shared_ptr< SpecUtils::Measurement const > > const &", "SWIGTYPE_p_std__vectorT_std__shared_ptrT_SpecUtils__MeasurVEY9A", "SpecUtils::SpecFile::remove_measurements(std::vector< std::shared_ptr< SpecUtils::Measurement const > > const &)", return );
  arg2 = (std::vector< std::shared_ptr< SpecUtils::Measurement const > > *)farg2->cptr;
  (arg1)->remove_measurements((std::vector< std::shared_ptr< SpecUtils::Measurement const > > const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_clear_multimedia_data(SwigClassWrapper *farg1) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::clear_multimedia_data()", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (arg1)->clear_multimedia_data();
}


SWIGEXPORT void _wrap_SpecFile_add_multimedia_data(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SpecUtils::MultimediaData *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::add_multimedia_data(SpecUtils::MultimediaData const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::MultimediaData const &", "MultimediaData", "SpecUtils::SpecFile::add_multimedia_data(SpecUtils::MultimediaData const &)", return );
  arg2 = (SpecUtils::MultimediaData *)farg2->cptr;
  (arg1)->add_multimedia_data((SpecUtils::MultimediaData const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_multimedia_data(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::shared_ptr< SpecUtils::MultimediaData const > > *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_multimedia_data(std::vector< std::shared_ptr< SpecUtils::MultimediaData const > > &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::shared_ptr< SpecUtils::MultimediaData const > > &", "SWIGTYPE_p_std__vectorT_std__shared_ptrT_SpecUtils__Multi1X71T7", "SpecUtils::SpecFile::set_multimedia_data(std::vector< std::shared_ptr< SpecUtils::MultimediaData const > > &)", return );
  arg2 = (std::vector< std::shared_ptr< SpecUtils::MultimediaData const > > *)farg2->cptr;
  (arg1)->set_multimedia_data(*arg2);
}


SWIGEXPORT int _wrap_SpecFile_occupancy_number_from_remarks(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  int result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::occupancy_number_from_remarks() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (int)((SpecUtils::SpecFile const *)arg1)->occupancy_number_from_remarks();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_sample_measurements(SwigClassWrapper *farg1, int const *farg2) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  int arg2 ;
  SwigValueWrapper< std::vector< std::shared_ptr< SpecUtils::Measurement const > > > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::sample_measurements(int const) const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (int)(*farg2);
  result = ((SpecUtils::SpecFile const *)arg1)->sample_measurements(arg2);
  fresult.cptr = new (std::vector< std::shared_ptr< SpecUtils::Measurement const > >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_measurement__SWIG_1(SwigClassWrapper *farg1, int const *farg2, SwigArrayWrapper *farg3) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  std::string tempstr3 ;
  std::shared_ptr< SpecUtils::Measurement const > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::measurement(int const,std::string const &) const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (int)(*farg2);
  tempstr3 = std::string(static_cast<char *>(farg3->data), farg3->size);
  arg3 = &tempstr3;
  result = ((SpecUtils::SpecFile const *)arg1)->measurement(arg2,(std::string const &)*arg3);
  fresult.cptr = result ? (new std::shared_ptr<const SpecUtils::Measurement >(static_cast< const std::shared_ptr<const SpecUtils::Measurement >& >(result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_measurement__SWIG_2(SwigClassWrapper *farg1, int const *farg2, int const *farg3) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  int arg2 ;
  int arg3 ;
  std::shared_ptr< SpecUtils::Measurement const > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::measurement(int const,int const) const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (int)(*farg2);
  arg3 = (int)(*farg3);
  result = ((SpecUtils::SpecFile const *)arg1)->measurement(arg2,arg3);
  fresult.cptr = result ? (new std::shared_ptr<const SpecUtils::Measurement >(static_cast< const std::shared_ptr<const SpecUtils::Measurement >& >(result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_suggested_sum_energy_calibration(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg2 = 0 ;
  std::vector< std::string > *arg3 = 0 ;
  SwigValueWrapper< std::shared_ptr< SpecUtils::EnergyCalibration const > > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::suggested_sum_energy_calibration(std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &) const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::suggested_sum_energy_calibration(std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &) const", return SwigClassWrapper_uninitialized());
  arg2 = (std::set< int,std::less< int >,std::allocator< int > > *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::suggested_sum_energy_calibration(std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &) const", return SwigClassWrapper_uninitialized());
  arg3 = (std::vector< std::string > *)farg3->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->suggested_sum_energy_calibration((std::set< int,std::less< int >,std::allocator< int > > const &)*arg2,(std::vector< std::string > const &)*arg3);
  fresult.cptr = new (std::shared_ptr< SpecUtils::EnergyCalibration const >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_sum_measurements(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg2 = 0 ;
  std::vector< std::string > *arg3 = 0 ;
  SwigValueWrapper< std::shared_ptr< SpecUtils::EnergyCalibration const > > arg4 ;
  std::shared_ptr< SpecUtils::Measurement > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::sum_measurements(std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &,std::shared_ptr< SpecUtils::EnergyCalibration const >) const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::sum_measurements(std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &,std::shared_ptr< SpecUtils::EnergyCalibration const >) const", return SwigClassWrapper_uninitialized());
  arg2 = (std::set< int,std::less< int >,std::allocator< int > > *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::sum_measurements(std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &,std::shared_ptr< SpecUtils::EnergyCalibration const >) const", return SwigClassWrapper_uninitialized());
  arg3 = (std::vector< std::string > *)farg3->cptr;
  SWIG_check_nonnull(farg4->cptr, "std::shared_ptr< SpecUtils::EnergyCalibration const >", "SWIGTYPE_p_std__shared_ptrT_SpecUtils__EnergyCalibration_cYBZ7Z", "SpecUtils::SpecFile::sum_measurements(std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &,std::shared_ptr< SpecUtils::EnergyCalibration const >) const", return SwigClassWrapper_uninitialized());
  arg4 = *((std::shared_ptr< SpecUtils::EnergyCalibration const > *)(farg4->cptr));
  result = ((SpecUtils::SpecFile const *)arg1)->sum_measurements((std::set< int,std::less< int >,std::allocator< int > > const &)*arg2,(std::vector< std::string > const &)*arg3,arg4);
  fresult.cptr = result ? (new std::shared_ptr< SpecUtils::Measurement >(static_cast< const std::shared_ptr< SpecUtils::Measurement >& >(result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT size_t _wrap_SpecFile_memmorysize(SwigClassWrapper *farg1) {
  size_t fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  size_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::memmorysize() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->memmorysize();
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_gamma_channel_counts(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SwigValueWrapper< std::set< size_t,std::less< size_t >,std::allocator< size_t > > > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::gamma_channel_counts() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->gamma_channel_counts();
  fresult.cptr = new (std::set< size_t,std::less< size_t >,std::allocator< size_t > >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT size_t _wrap_SpecFile_num_gamma_channels(SwigClassWrapper *farg1) {
  size_t fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  size_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::num_gamma_channels() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->num_gamma_channels();
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_SpecFile_keep_n_bin_spectra_only(SwigClassWrapper *farg1, size_t const *farg2) {
  size_t fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  size_t arg2 ;
  size_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::keep_n_bin_spectra_only(size_t)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (size_t)(*farg2);
  result = (arg1)->keep_n_bin_spectra_only(arg2);
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_contained_neutron(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::contained_neutron() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->contained_neutron();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_energy_cal_variants(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SwigValueWrapper< std::set< std::string,std::less< std::string >,std::allocator< std::string > > > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::energy_cal_variants() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->energy_cal_variants();
  fresult.cptr = new (std::set< std::string,std::less< std::string >,std::allocator< std::string > >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT size_t _wrap_SpecFile_keep_energy_cal_variants(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  size_t fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::set< std::string,std::less< std::string >,std::allocator< std::string > > *arg2 = 0 ;
  size_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::keep_energy_cal_variants(std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &", "SWIGTYPE_p_std__setT_std__string_std__lessT_std__string_t1Q4VKZ", "SpecUtils::SpecFile::keep_energy_cal_variants(std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &)", return 0);
  arg2 = (std::set< std::string,std::less< std::string >,std::allocator< std::string > > *)farg2->cptr;
  result = (arg1)->keep_energy_cal_variants((std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &)*arg2);
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_SpecFile_keep_derived_data_variant(SwigClassWrapper *farg1, int const *farg2) {
  size_t fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SpecUtils::SpecFile::DerivedVariantToKeep arg2 ;
  size_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::keep_derived_data_variant(SpecUtils::SpecFile::DerivedVariantToKeep const)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (SpecUtils::SpecFile::DerivedVariantToKeep)(*farg2);
  result = (arg1)->keep_derived_data_variant(arg2);
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_SpecFile_remove_detectors_data(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  size_t fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::set< std::string,std::less< std::string >,std::allocator< std::string > > *arg2 = 0 ;
  size_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::remove_detectors_data(std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &", "SWIGTYPE_p_std__setT_std__string_std__lessT_std__string_t1Q4VKZ", "SpecUtils::SpecFile::remove_detectors_data(std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &)", return 0);
  arg2 = (std::set< std::string,std::less< std::string >,std::allocator< std::string > > *)farg2->cptr;
  result = (arg1)->remove_detectors_data((std::set< std::string,std::less< std::string >,std::allocator< std::string > > const &)*arg2);
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT size_t _wrap_SpecFile_remove_neutron_measurements(SwigClassWrapper *farg1) {
  size_t fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  size_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::remove_neutron_measurements()", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (arg1)->remove_neutron_measurements();
  fresult = (size_t)(result);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_background_sample_number(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  int result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::background_sample_number() const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (int)((SpecUtils::SpecFile const *)arg1)->background_sample_number();
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigArrayWrapper _wrap_SpecFile_generate_psuedo_uuid(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::generate_psuedo_uuid() const", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->generate_psuedo_uuid();
  fresult.size = (&result)->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, (&result)->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_SpecFile_reset(SwigClassWrapper *farg1) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::reset()", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (arg1)->reset();
}


SWIGEXPORT int _wrap_SpecFile_load_N42_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_N42_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_N42_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_pcf_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_pcf_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_pcf_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_spc_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_spc_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_spc_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_chn_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_chn_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_chn_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_iaea_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_iaea_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_iaea_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_binary_exploranium_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_binary_exploranium_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_binary_exploranium_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_micro_raider_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_micro_raider_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_micro_raider_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_txt_or_csv_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_txt_or_csv_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_txt_or_csv_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_cnf_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_cnf_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_cnf_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_tracs_mps_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_tracs_mps_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_tracs_mps_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_aram_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_aram_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_aram_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_spectroscopic_daily_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_spectroscopic_daily_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_spectroscopic_daily_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_amptek_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_amptek_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_amptek_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_ortec_listmode_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_ortec_listmode_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_ortec_listmode_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_lsrm_spe_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_lsrm_spe_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_lsrm_spe_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_tka_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_tka_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_tka_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_multiact_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_multiact_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_multiact_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_phd_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_phd_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_phd_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_lzs_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_lzs_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_lzs_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_radiacode_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_radiacode_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_radiacode_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_xml_scan_data_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_xml_scan_data_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_xml_scan_data_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_json_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_json_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_json_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_caen_gxml_file(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_caen_gxml_file(std::string const &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  result = (bool)(arg1)->load_caen_gxml_file((std::string const &)*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_N42(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_N42(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_N42(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_N42(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_N42_from_data__SWIG_0(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_N42_from_data(char *)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (char *)(farg2->data);
  result = (bool)(arg1)->load_N42_from_data(arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_N42_from_data__SWIG_1(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, SwigArrayWrapper *farg3) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_N42_from_data(char *,char *)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (char *)(farg2->data);
  arg3 = (char *)(farg3->data);
  result = (bool)(arg1)->load_N42_from_data(arg2,arg3);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_iaea_spc(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_iaea_spc(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_iaea_spc(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_iaea_spc(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_binary_spc(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_binary_spc(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_binary_spc(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_binary_spc(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_N42_document(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  rapidxml::xml_node< char > *arg2 = (rapidxml::xml_node< char > *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_N42_document(rapidxml::xml_node< char > const *)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (rapidxml::xml_node< char > *)farg2->cptr;
  result = (bool)(arg1)->load_from_N42_document((rapidxml::xml_node< char > const *)arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_micro_raider_from_data(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_micro_raider_from_data(char const *)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (char *)(farg2->data);
  result = (bool)(arg1)->load_from_micro_raider_from_data((char const *)arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_binary_exploranium(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_binary_exploranium(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_binary_exploranium(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_binary_exploranium(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_pcf(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_pcf(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_pcf(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_pcf(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_txt_or_csv(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_txt_or_csv(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_txt_or_csv(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_txt_or_csv(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_Gr135_txt(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_Gr135_txt(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_Gr135_txt(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_Gr135_txt(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_spectroscopic_daily_file(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_spectroscopic_daily_file(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_spectroscopic_daily_file(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_spectroscopic_daily_file(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_srpm210_csv(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_srpm210_csv(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_srpm210_csv(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_srpm210_csv(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_D3S_raw(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_D3S_raw(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_D3S_raw(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_D3S_raw(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_amptek_mca(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_amptek_mca(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_amptek_mca(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_amptek_mca(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_ortec_listmode(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_ortec_listmode(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_ortec_listmode(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_ortec_listmode(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_lsrm_spe(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_lsrm_spe(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_lsrm_spe(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_lsrm_spe(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_tka(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_tka(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_tka(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_tka(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_multiact(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_multiact(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_multiact(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_multiact(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_phd(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_phd(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_phd(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_phd(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_lzs(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_lzs(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_lzs(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_lzs(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_radiacode(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_radiacode(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_radiacode(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_radiacode(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_radiacode_spectrogram(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_radiacode_spectrogram(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_radiacode_spectrogram(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_radiacode_spectrogram(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_xml_scan_data(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_xml_scan_data(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_xml_scan_data(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_xml_scan_data(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_iaea(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_iaea(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_iaea(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_iaea(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_chn(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_chn(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_chn(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_chn(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_cnf(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_cnf(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_cnf(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_cnf(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_tracs_mps(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_tracs_mps(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_tracs_mps(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_tracs_mps(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_aram(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_aram(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_aram(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_aram(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_json(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_json(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_json(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_json(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_load_from_caen_gxml(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::load_from_caen_gxml(std::istream &)", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::load_from_caen_gxml(std::istream &)", return 0);
  arg2 = (std::istream *)farg2->cptr;
  result = (bool)(arg1)->load_from_caen_gxml(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT SWIGEXTERN const int _wrap_SpecFile_RebinToCommonBinning = (int)(SpecUtils::SpecFile::RebinToCommonBinning);

SWIGEXPORT SWIGEXTERN const int _wrap_SpecFile_DontChangeOrReorderSamples = (int)(SpecUtils::SpecFile::DontChangeOrReorderSamples);

SWIGEXPORT SWIGEXTERN const int _wrap_SpecFile_ReorderSamplesByTime = (int)(SpecUtils::SpecFile::ReorderSamplesByTime);

SWIGEXPORT SWIGEXTERN const int _wrap_SpecFile_StandardCleanup = (int)(SpecUtils::SpecFile::StandardCleanup);

SWIGEXPORT void _wrap_SpecFile_cleanup_after_load__SWIG_0(SwigClassWrapper *farg1, int const *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::cleanup_after_load(unsigned int const)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (unsigned int)(*farg2);
  (arg1)->cleanup_after_load(arg2);
}


SWIGEXPORT void _wrap_SpecFile_cleanup_after_load__SWIG_1(SwigClassWrapper *farg1) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::cleanup_after_load()", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (arg1)->cleanup_after_load();
}


SWIGEXPORT void _wrap_SpecFile_recalc_total_counts(SwigClassWrapper *farg1) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::recalc_total_counts()", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (arg1)->recalc_total_counts();
}


SWIGEXPORT void _wrap_SpecFile_merge_neutron_meas_into_gamma_meas(SwigClassWrapper *farg1) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::merge_neutron_meas_into_gamma_meas()", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (arg1)->merge_neutron_meas_into_gamma_meas();
}


SWIGEXPORT void _wrap_SpecFile_rebin_measurement(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::shared_ptr< SpecUtils::EnergyCalibration const > *arg2 = 0 ;
  std::shared_ptr< SpecUtils::Measurement const > *arg3 = 0 ;
  std::shared_ptr< SpecUtils::Measurement const > tempnull3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::rebin_measurement(std::shared_ptr< SpecUtils::EnergyCalibration const > const &,std::shared_ptr< SpecUtils::Measurement const > const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::shared_ptr< SpecUtils::EnergyCalibration const > const &", "SWIGTYPE_p_std__shared_ptrT_SpecUtils__EnergyCalibration_cYBZ7Z", "SpecUtils::SpecFile::rebin_measurement(std::shared_ptr< SpecUtils::EnergyCalibration const > const &,std::shared_ptr< SpecUtils::Measurement const > const &)", return );
  arg2 = (std::shared_ptr< SpecUtils::EnergyCalibration const > *)farg2->cptr;
  arg3 = farg3->cptr ? static_cast<std::shared_ptr< SpecUtils::Measurement const > * >(farg3->cptr) : &tempnull3;
  (arg1)->rebin_measurement((std::shared_ptr< SpecUtils::EnergyCalibration const > const &)*arg2,(std::shared_ptr< SpecUtils::Measurement const > const &)*arg3);
}


SWIGEXPORT void _wrap_SpecFile_rebin_all_measurements(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::shared_ptr< SpecUtils::EnergyCalibration const > *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::rebin_all_measurements(std::shared_ptr< SpecUtils::EnergyCalibration const > const &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::shared_ptr< SpecUtils::EnergyCalibration const > const &", "SWIGTYPE_p_std__shared_ptrT_SpecUtils__EnergyCalibration_cYBZ7Z", "SpecUtils::SpecFile::rebin_all_measurements(std::shared_ptr< SpecUtils::EnergyCalibration const > const &)", return );
  arg2 = (std::shared_ptr< SpecUtils::EnergyCalibration const > *)farg2->cptr;
  (arg1)->rebin_all_measurements((std::shared_ptr< SpecUtils::EnergyCalibration const > const &)*arg2);
}


SWIGEXPORT void _wrap_SpecFile_set_energy_calibration_from_CALp_file(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::istream *arg2 = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::set_energy_calibration_from_CALp_file(std::istream &)", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::istream &", "SWIGTYPE_p_std__istream", "SpecUtils::SpecFile::set_energy_calibration_from_CALp_file(std::istream &)", return );
  arg2 = (std::istream *)farg2->cptr;
  (arg1)->set_energy_calibration_from_CALp_file(*arg2);
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_detector_names_to_numbers(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::detector_names_to_numbers(std::vector< std::string > const &) const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::detector_names_to_numbers(std::vector< std::string > const &) const", return SwigClassWrapper_uninitialized());
  arg2 = (std::vector< std::string > *)farg2->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->detector_names_to_numbers((std::vector< std::string > const &)*arg2);
  fresult.cptr = new (std::set< int,std::less< int >,std::allocator< int > >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT void _wrap_SpecFile_write_to_file__SWIG_0(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, int const *farg3) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string arg2 ;
  SpecUtils::SaveSpectrumAsType arg3 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_to_file(std::string const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (&arg2)->assign(static_cast<char *>(farg2->data), farg2->size);
  arg3 = (SpecUtils::SaveSpectrumAsType)(*farg3);
  ((SpecUtils::SpecFile const *)arg1)->write_to_file(arg2,arg3);
}


SWIGEXPORT void _wrap_SpecFile_write_to_file__SWIG_1(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4, int const *farg5) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string arg2 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg4 ;
  SpecUtils::SaveSpectrumAsType arg5 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_to_file(std::string const,std::set< int,std::less< int >,std::allocator< int > > const,std::set< int,std::less< int >,std::allocator< int > > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (&arg2)->assign(static_cast<char *>(farg2->data), farg2->size);
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_to_file(std::string const,std::set< int,std::less< int >,std::allocator< int > > const,std::set< int,std::less< int >,std::allocator< int > > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_to_file(std::string const,std::set< int,std::less< int >,std::allocator< int > > const,std::set< int,std::less< int >,std::allocator< int > > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg4 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg4->cptr));
  arg5 = (SpecUtils::SaveSpectrumAsType)(*farg5);
  ((SpecUtils::SpecFile const *)arg1)->write_to_file(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void _wrap_SpecFile_write_to_file__SWIG_2(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4, int const *farg5) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string arg2 ;
  std::vector< int > arg3 ;
  std::vector< int > arg4 ;
  SpecUtils::SaveSpectrumAsType arg5 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_to_file(std::string const,std::vector< int > const,std::vector< int > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  (&arg2)->assign(static_cast<char *>(farg2->data), farg2->size);
  SWIG_check_nonnull(farg3->cptr, "std::vector< int >", "IntVector", "SpecUtils::SpecFile::write_to_file(std::string const,std::vector< int > const,std::vector< int > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg3 = *((std::vector< int > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::vector< int >", "IntVector", "SpecUtils::SpecFile::write_to_file(std::string const,std::vector< int > const,std::vector< int > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg4 = *((std::vector< int > *)(farg4->cptr));
  arg5 = (SpecUtils::SaveSpectrumAsType)(*farg5);
  ((SpecUtils::SpecFile const *)arg1)->write_to_file(arg2,arg3,arg4,arg5);
}


SWIGEXPORT void _wrap_SpecFile_write_to_file__SWIG_3(SwigClassWrapper *farg1, SwigArrayWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4, int const *farg5) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::string *arg2 = 0 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg3 = 0 ;
  std::vector< std::string > *arg4 = 0 ;
  SpecUtils::SaveSpectrumAsType arg5 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_to_file(std::string const &,std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &,SpecUtils::SaveSpectrumAsType const) const", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_to_file(std::string const &,std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &,SpecUtils::SaveSpectrumAsType const) const", return );
  arg3 = (std::set< int,std::less< int >,std::allocator< int > > *)farg3->cptr;
  SWIG_check_nonnull(farg4->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::write_to_file(std::string const &,std::set< int,std::less< int >,std::allocator< int > > const &,std::vector< std::string > const &,SpecUtils::SaveSpectrumAsType const) const", return );
  arg4 = (std::vector< std::string > *)farg4->cptr;
  arg5 = (SpecUtils::SaveSpectrumAsType)(*farg5);
  ((SpecUtils::SpecFile const *)arg1)->write_to_file((std::string const &)*arg2,(std::set< int,std::less< int >,std::allocator< int > > const &)*arg3,(std::vector< std::string > const &)*arg4,arg5);
}


SWIGEXPORT void _wrap_SpecFile_write__SWIG_0(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4, int const *farg5) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg4 ;
  SpecUtils::SaveSpectrumAsType arg5 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg2 = (std::ostream *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const,SpecUtils::SaveSpectrumAsType const) const", return );
  arg4 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg4->cptr));
  arg5 = (SpecUtils::SaveSpectrumAsType)(*farg5);
  ((SpecUtils::SpecFile const *)arg1)->write(*arg2,arg3,arg4,arg5);
}


SWIGEXPORT void _wrap_SpecFile_write__SWIG_1(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4, int const *farg5) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  SpecUtils::SaveSpectrumAsType arg5 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::vector< std::string > const &,SpecUtils::SaveSpectrumAsType const) const", return );
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::vector< std::string > const &,SpecUtils::SaveSpectrumAsType const) const", return );
  arg2 = (std::ostream *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::vector< std::string > const &,SpecUtils::SaveSpectrumAsType const) const", return );
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::write(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::vector< std::string > const &,SpecUtils::SaveSpectrumAsType const) const", return );
  arg4 = (std::vector< std::string > *)farg4->cptr;
  arg5 = (SpecUtils::SaveSpectrumAsType)(*farg5);
  ((SpecUtils::SpecFile const *)arg1)->write(*arg2,arg3,(std::vector< std::string > const &)*arg4,arg5);
}


SWIGEXPORT int _wrap_SpecFile_write_pcf(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_pcf(std::ostream &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_pcf(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_pcf(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_2006_N42(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_2006_N42(std::ostream &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_2006_N42(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_2006_N42(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_csv(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_csv(std::ostream &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_csv(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_csv(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_txt(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_txt(std::ostream &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_txt(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_txt(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_integer_chn__SWIG_0(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg4 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_integer_chn(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_integer_chn(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_integer_chn(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_integer_chn(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg4 = (std::set< int,std::less< int >,std::allocator< int > > *)farg4->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_integer_chn(*arg2,arg3,(std::set< int,std::less< int >,std::allocator< int > > const &)*arg4);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_integer_chn__SWIG_1(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  std::vector< std::string > *arg4 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_integer_chn(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::vector< std::string > const &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_integer_chn(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::vector< std::string > const &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_integer_chn(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::vector< std::string > const &) const", return 0);
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::vector< std::string > const &", "SWIGTYPE_p_std__vectorT_std__string_t", "SpecUtils::SpecFile::write_integer_chn(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::vector< std::string > const &) const", return 0);
  arg4 = (std::vector< std::string > *)farg4->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_integer_chn(*arg2,arg3,(std::vector< std::string > const &)*arg4);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_binary_spc(SwigClassWrapper *farg1, SwigClassWrapper *farg2, int const *farg3, SwigClassWrapper *farg4, SwigClassWrapper *farg5) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SpecUtils::SpecFile::SpcBinaryType arg3 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg4 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg5 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_binary_spc(std::ostream &,SpecUtils::SpecFile::SpcBinaryType const,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_binary_spc(std::ostream &,SpecUtils::SpecFile::SpcBinaryType const,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  arg3 = (SpecUtils::SpecFile::SpcBinaryType)(*farg3);
  SWIG_check_nonnull(farg4->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_binary_spc(std::ostream &,SpecUtils::SpecFile::SpcBinaryType const,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg4 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg4->cptr));
  SWIG_check_nonnull(farg5->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_binary_spc(std::ostream &,SpecUtils::SpecFile::SpcBinaryType const,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg5 = (std::set< int,std::less< int >,std::allocator< int > > *)farg5->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_binary_spc(*arg2,arg3,arg4,(std::set< int,std::less< int >,std::allocator< int > > const &)*arg5);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_ascii_spc(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg4 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_ascii_spc(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_ascii_spc(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_ascii_spc(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_ascii_spc(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg4 = (std::set< int,std::less< int >,std::allocator< int > > *)farg4->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_ascii_spc(*arg2,arg3,(std::set< int,std::less< int >,std::allocator< int > > const &)*arg4);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_binary_exploranium_gr130v0(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_binary_exploranium_gr130v0(std::ostream &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_binary_exploranium_gr130v0(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_binary_exploranium_gr130v0(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_binary_exploranium_gr135v2(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_binary_exploranium_gr135v2(std::ostream &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_binary_exploranium_gr135v2(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_binary_exploranium_gr135v2(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_iaea_spe(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg4 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_iaea_spe(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_iaea_spe(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_iaea_spe(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_iaea_spe(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg4 = (std::set< int,std::less< int >,std::allocator< int > > *)farg4->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_iaea_spe(*arg2,arg3,(std::set< int,std::less< int >,std::allocator< int > > const &)*arg4);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_cnf(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg4 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_cnf(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_cnf(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_cnf(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_cnf(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg4 = (std::set< int,std::less< int >,std::allocator< int > > *)farg4->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_cnf(*arg2,arg3,(std::set< int,std::less< int >,std::allocator< int > > const &)*arg4);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_tka(SwigClassWrapper *farg1, SwigClassWrapper *farg2, SwigClassWrapper *farg3, SwigClassWrapper *farg4) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  SwigValueWrapper< std::set< int,std::less< int >,std::allocator< int > > > arg3 ;
  std::set< int,std::less< int >,std::allocator< int > > *arg4 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_tka(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_tka(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  SWIG_check_nonnull(farg3->cptr, "std::set< int,std::less< int >,std::allocator< int > >", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_tka(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg3 = *((std::set< int,std::less< int >,std::allocator< int > > *)(farg3->cptr));
  SWIG_check_nonnull(farg4->cptr, "std::set< int,std::less< int >,std::allocator< int > > const &", "SWIGTYPE_p_std__setT_int_std__lessT_int_t_std__allocatorT10FDJ2", "SpecUtils::SpecFile::write_tka(std::ostream &,std::set< int,std::less< int >,std::allocator< int > >,std::set< int,std::less< int >,std::allocator< int > > const &) const", return 0);
  arg4 = (std::set< int,std::less< int >,std::allocator< int > > *)farg4->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_tka(*arg2,arg3,(std::set< int,std::less< int >,std::allocator< int > > const &)*arg4);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_2012N42_VERSION_get() {
  int fresult ;
  int result;
  
  result = (int)(5);
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_create_2012_N42_xml(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SwigValueWrapper< std::shared_ptr< ::rapidxml::xml_document< char > > > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::create_2012_N42_xml() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = ((SpecUtils::SpecFile const *)arg1)->create_2012_N42_xml();
  fresult.cptr = new (std::shared_ptr< ::rapidxml::xml_document< char > >)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT int _wrap_SpecFile_write_2012_N42(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  int fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::ostream *arg2 = 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::write_2012_N42(std::ostream &) const", return 0);
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "std::ostream &", "SWIGTYPE_p_std__ostream", "SpecUtils::SpecFile::write_2012_N42(std::ostream &) const", return 0);
  arg2 = (std::ostream *)farg2->cptr;
  result = (bool)((SpecUtils::SpecFile const *)arg1)->write_2012_N42(*arg2);
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_mutex(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  std::recursive_mutex *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile const *", "SpecFile", "SpecUtils::SpecFile::mutex() const", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  result = (std::recursive_mutex *) &((SpecUtils::SpecFile const *)arg1)->mutex();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_SpecFile_measurement_at(SwigClassWrapper *farg1, int const *farg2) {
  SwigClassWrapper fresult ;
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  int arg2 ;
  std::shared_ptr< SpecUtils::Measurement const > result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::SpecFile *", "SpecFile", "SpecUtils::SpecFile::measurement_at(int)", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::SpecFile *)farg1->cptr;
  arg2 = (int)(*farg2);
  result = SpecUtils_SpecFile_measurement_at(arg1,arg2);
  fresult.cptr = result ? (new std::shared_ptr<const SpecUtils::Measurement >(static_cast< const std::shared_ptr<const SpecUtils::Measurement >& >(result))) : NULL;
  fresult.cmemflags = SWIG_MEM_OWN | SWIG_MEM_RVALUE;
  return fresult;
}


SWIGEXPORT void _wrap_SpecFile_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::SpecFile *arg1 = (SpecUtils::SpecFile *) 0 ;
  SpecUtils::SpecFile *arg2 = 0 ;
  
  (void)sizeof(arg1);
  (void)sizeof(arg2);
  SWIG_assign<SpecUtils::SpecFile, SWIGPOLICY_SpecUtils_SpecFile>(farg1, *farg2);
  
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_remark__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::remark_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->remark_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysisResult_remark__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::remark_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (std::string *) & ((arg1)->remark_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_nuclide__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::nuclide_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->nuclide_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysisResult_nuclide__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::nuclide_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (std::string *) & ((arg1)->nuclide_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_activity__set(SwigClassWrapper *farg1, float const *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  float arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::activity_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  arg2 = (float)(*farg2);
  if (arg1) (arg1)->activity_ = arg2;
}


SWIGEXPORT float _wrap_DetectorAnalysisResult_activity__get(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  float result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::activity_", return 0);
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (float) ((arg1)->activity_);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_nuclide_type__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::nuclide_type_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->nuclide_type_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysisResult_nuclide_type__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::nuclide_type_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (std::string *) & ((arg1)->nuclide_type_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_id_confidence__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::id_confidence_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->id_confidence_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysisResult_id_confidence__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::id_confidence_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (std::string *) & ((arg1)->id_confidence_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_distance__set(SwigClassWrapper *farg1, float const *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  float arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::distance_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  arg2 = (float)(*farg2);
  if (arg1) (arg1)->distance_ = arg2;
}


SWIGEXPORT float _wrap_DetectorAnalysisResult_distance__get(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  float result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::distance_", return 0);
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (float) ((arg1)->distance_);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_dose_rate__set(SwigClassWrapper *farg1, float const *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  float arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::dose_rate_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  arg2 = (float)(*farg2);
  if (arg1) (arg1)->dose_rate_ = arg2;
}


SWIGEXPORT float _wrap_DetectorAnalysisResult_dose_rate__get(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  float result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::dose_rate_", return 0);
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (float) ((arg1)->dose_rate_);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_real_time__set(SwigClassWrapper *farg1, float const *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  float arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::real_time_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  arg2 = (float)(*farg2);
  if (arg1) (arg1)->real_time_ = arg2;
}


SWIGEXPORT float _wrap_DetectorAnalysisResult_real_time__get(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  float result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::real_time_", return 0);
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (float) ((arg1)->real_time_);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_detector__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::detector_", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->detector_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysisResult_detector__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::detector_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (std::string *) & ((arg1)->detector_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_DetectorAnalysisResult() {
  SwigClassWrapper fresult ;
  SpecUtils::DetectorAnalysisResult *result = 0 ;
  
  result = (SpecUtils::DetectorAnalysisResult *)new SpecUtils::DetectorAnalysisResult();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_reset(SwigClassWrapper *farg1) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::reset()", return );
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  (arg1)->reset();
}


SWIGEXPORT int _wrap_DetectorAnalysisResult_isEmpty(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysisResult const *", "DetectorAnalysisResult", "SpecUtils::DetectorAnalysisResult::isEmpty() const", return 0);
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  result = (bool)((SpecUtils::DetectorAnalysisResult const *)arg1)->isEmpty();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT void _wrap_delete_DetectorAnalysisResult(SwigClassWrapper *farg1) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  
  arg1 = (SpecUtils::DetectorAnalysisResult *)farg1->cptr;
  delete arg1;
}


SWIGEXPORT void _wrap_DetectorAnalysisResult_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::DetectorAnalysisResult *arg1 = (SpecUtils::DetectorAnalysisResult *) 0 ;
  SpecUtils::DetectorAnalysisResult *arg2 = 0 ;
  
  (void)sizeof(arg1);
  (void)sizeof(arg2);
  SWIG_assign<SpecUtils::DetectorAnalysisResult, SWIGPOLICY_SpecUtils_DetectorAnalysisResult>(farg1, *farg2);
  
}


SWIGEXPORT void _wrap_DetectorAnalysis_remarks__set(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::vector< std::string > *arg2 = (std::vector< std::string > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::remarks_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  arg2 = (std::vector< std::string > *)farg2->cptr;
  if (arg1) (arg1)->remarks_ = *arg2;
}


SWIGEXPORT SwigClassWrapper _wrap_DetectorAnalysis_remarks__get(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::vector< std::string > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::remarks_", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (std::vector< std::string > *)& ((arg1)->remarks_);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_algorithm_name__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_name_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->algorithm_name_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysis_algorithm_name__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_name_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (std::string *) & ((arg1)->algorithm_name_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_algorithm_component_versions__set(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::vector< std::pair< std::string,std::string > > *arg2 = (std::vector< std::pair< std::string,std::string > > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_component_versions_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  arg2 = (std::vector< std::pair< std::string,std::string > > *)farg2->cptr;
  if (arg1) (arg1)->algorithm_component_versions_ = *arg2;
}


SWIGEXPORT SwigClassWrapper _wrap_DetectorAnalysis_algorithm_component_versions__get(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::vector< std::pair< std::string,std::string > > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_component_versions_", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (std::vector< std::pair< std::string,std::string > > *)& ((arg1)->algorithm_component_versions_);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_algorithm_creator__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_creator_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->algorithm_creator_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysis_algorithm_creator__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_creator_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (std::string *) & ((arg1)->algorithm_creator_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_algorithm_description__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_description_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->algorithm_description_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysis_algorithm_description__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_description_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (std::string *) & ((arg1)->algorithm_description_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_analysis_start_time__set(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  SpecUtils::time_point_t arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::analysis_start_time_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::time_point_t", "SWIGTYPE_p_std__chrono__time_pointT_std__chrono__system_c1Q0CUN", "SpecUtils::DetectorAnalysis::analysis_start_time_", return );
  arg2 = *((SpecUtils::time_point_t *)(farg2->cptr));
  if (arg1) (arg1)->analysis_start_time_ = arg2;
}


SWIGEXPORT SwigClassWrapper _wrap_DetectorAnalysis_analysis_start_time__get(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  SpecUtils::time_point_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::analysis_start_time_", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result =  ((arg1)->analysis_start_time_);
  fresult.cptr = new (SpecUtils::time_point_t)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_analysis_computation_duration__set(SwigClassWrapper *farg1, float const *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  float arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::analysis_computation_duration_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  arg2 = (float)(*farg2);
  if (arg1) (arg1)->analysis_computation_duration_ = arg2;
}


SWIGEXPORT float _wrap_DetectorAnalysis_analysis_computation_duration__get(SwigClassWrapper *farg1) {
  float fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  float result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::analysis_computation_duration_", return 0);
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (float) ((arg1)->analysis_computation_duration_);
  fresult = (float)(result);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_algorithm_result_description__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_result_description_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->algorithm_result_description_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_DetectorAnalysis_algorithm_result_description__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::algorithm_result_description_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (std::string *) & ((arg1)->algorithm_result_description_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_results__set(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::vector< SpecUtils::DetectorAnalysisResult > *arg2 = (std::vector< SpecUtils::DetectorAnalysisResult > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::results_", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  arg2 = (std::vector< SpecUtils::DetectorAnalysisResult > *)farg2->cptr;
  if (arg1) (arg1)->results_ = *arg2;
}


SWIGEXPORT SwigClassWrapper _wrap_DetectorAnalysis_results__get(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  std::vector< SpecUtils::DetectorAnalysisResult > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::results_", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (std::vector< SpecUtils::DetectorAnalysisResult > *)& ((arg1)->results_);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_DetectorAnalysis() {
  SwigClassWrapper fresult ;
  SpecUtils::DetectorAnalysis *result = 0 ;
  
  result = (SpecUtils::DetectorAnalysis *)new SpecUtils::DetectorAnalysis();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_DetectorAnalysis_reset(SwigClassWrapper *farg1) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::reset()", return );
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  (arg1)->reset();
}


SWIGEXPORT int _wrap_DetectorAnalysis_is_empty(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  bool result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::DetectorAnalysis const *", "DetectorAnalysis", "SpecUtils::DetectorAnalysis::is_empty() const", return 0);
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  result = (bool)((SpecUtils::DetectorAnalysis const *)arg1)->is_empty();
  fresult = (result ? 1 : 0);
  return fresult;
}


SWIGEXPORT void _wrap_delete_DetectorAnalysis(SwigClassWrapper *farg1) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  
  arg1 = (SpecUtils::DetectorAnalysis *)farg1->cptr;
  delete arg1;
}


SWIGEXPORT void _wrap_DetectorAnalysis_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::DetectorAnalysis *arg1 = (SpecUtils::DetectorAnalysis *) 0 ;
  SpecUtils::DetectorAnalysis *arg2 = 0 ;
  
  (void)sizeof(arg1);
  (void)sizeof(arg2);
  SWIG_assign<SpecUtils::DetectorAnalysis, SWIGPOLICY_SpecUtils_DetectorAnalysis>(farg1, *farg2);
  
}


SWIGEXPORT void _wrap_MultimediaData_remark__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::remark_", return );
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->remark_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_MultimediaData_remark__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::remark_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  result = (std::string *) & ((arg1)->remark_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_MultimediaData_descriptions__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::descriptions_", return );
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->descriptions_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_MultimediaData_descriptions__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::descriptions_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  result = (std::string *) & ((arg1)->descriptions_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_MultimediaData_data__set(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::vector< char > *arg2 = (std::vector< char > *) 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::data_", return );
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  arg2 = (std::vector< char > *)farg2->cptr;
  if (arg1) (arg1)->data_ = *arg2;
}


SWIGEXPORT SwigClassWrapper _wrap_MultimediaData_data__get(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::vector< char > *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::data_", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  result = (std::vector< char > *)& ((arg1)->data_);
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (0 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_MultimediaData_data_encoding__set(SwigClassWrapper *farg1, int const *farg2) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  SpecUtils::MultimediaData::EncodingType arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::data_encoding_", return );
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  arg2 = (SpecUtils::MultimediaData::EncodingType)(*farg2);
  if (arg1) (arg1)->data_encoding_ = arg2;
}


SWIGEXPORT int _wrap_MultimediaData_data_encoding__get(SwigClassWrapper *farg1) {
  int fresult ;
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  SpecUtils::MultimediaData::EncodingType result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::data_encoding_", return 0);
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  result = (SpecUtils::MultimediaData::EncodingType) ((arg1)->data_encoding_);
  fresult = (int)(result);
  return fresult;
}


SWIGEXPORT void _wrap_MultimediaData_capture_start_time__set(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  SpecUtils::time_point_t arg2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::capture_start_time_", return );
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  SWIG_check_nonnull(farg2->cptr, "SpecUtils::time_point_t", "SWIGTYPE_p_std__chrono__time_pointT_std__chrono__system_c1Q0CUN", "SpecUtils::MultimediaData::capture_start_time_", return );
  arg2 = *((SpecUtils::time_point_t *)(farg2->cptr));
  if (arg1) (arg1)->capture_start_time_ = arg2;
}


SWIGEXPORT SwigClassWrapper _wrap_MultimediaData_capture_start_time__get(SwigClassWrapper *farg1) {
  SwigClassWrapper fresult ;
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  SpecUtils::time_point_t result;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::capture_start_time_", return SwigClassWrapper_uninitialized());
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  result =  ((arg1)->capture_start_time_);
  fresult.cptr = new (SpecUtils::time_point_t)(result);
  fresult.cmemflags = SWIG_MEM_RVALUE | SWIG_MEM_OWN;
  return fresult;
}


SWIGEXPORT void _wrap_MultimediaData_file_uri__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::file_uri_", return );
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->file_uri_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_MultimediaData_file_uri__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::file_uri_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  result = (std::string *) & ((arg1)->file_uri_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT void _wrap_MultimediaData_mime_type__set(SwigClassWrapper *farg1, SwigArrayWrapper *farg2) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::string *arg2 = 0 ;
  std::string tempstr2 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::mime_type_", return );
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  tempstr2 = std::string(static_cast<char *>(farg2->data), farg2->size);
  arg2 = &tempstr2;
  if (arg1) (arg1)->mime_type_ = *arg2;
}


SWIGEXPORT SwigArrayWrapper _wrap_MultimediaData_mime_type__get(SwigClassWrapper *farg1) {
  SwigArrayWrapper fresult ;
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  std::string *result = 0 ;
  
  SWIG_check_nonnull(farg1->cptr, "SpecUtils::MultimediaData *", "MultimediaData", "SpecUtils::MultimediaData::mime_type_", return SwigArrayWrapper_uninitialized());
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  result = (std::string *) & ((arg1)->mime_type_);
  fresult.size = result->size();
  if (fresult.size > 0) {
    fresult.data = malloc(fresult.size);
    memcpy(fresult.data, result->c_str(), fresult.size);
  } else {
    fresult.data = NULL;
  }
  return fresult;
}


SWIGEXPORT SwigClassWrapper _wrap_new_MultimediaData() {
  SwigClassWrapper fresult ;
  SpecUtils::MultimediaData *result = 0 ;
  
  result = (SpecUtils::MultimediaData *)new SpecUtils::MultimediaData();
  fresult.cptr = (void*)result;
  fresult.cmemflags = SWIG_MEM_RVALUE | (1 ? SWIG_MEM_OWN : 0);
  return fresult;
}


SWIGEXPORT void _wrap_delete_MultimediaData(SwigClassWrapper *farg1) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  
  arg1 = (SpecUtils::MultimediaData *)farg1->cptr;
  delete arg1;
}


SWIGEXPORT void _wrap_MultimediaData_op_assign__(SwigClassWrapper *farg1, SwigClassWrapper *farg2) {
  SpecUtils::MultimediaData *arg1 = (SpecUtils::MultimediaData *) 0 ;
  SpecUtils::MultimediaData *arg2 = 0 ;
  
  (void)sizeof(arg1);
  (void)sizeof(arg2);
  SWIG_assign<SpecUtils::MultimediaData, SWIGPOLICY_SpecUtils_MultimediaData>(farg1, *farg2);
  
}


} // extern

